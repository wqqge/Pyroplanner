<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>üéÜ FirePlanner 2D - Pro</title>
<style>
body {
  box-sizing: border-box;
  font-family: Arial, sans-serif;
  margin: 0;
  background: #111;
  color: #eee;
}
h1, h2 {
  text-align: center;
  margin: 10px 0;
}
input, button, select, textarea {
  margin: 5px;
  padding: 8px;
  background: #222;
  color: #fff;
  border: 1px solid #555;
  border-radius: 5px;
  font-size: 14px;
  outline: none;
}

input:focus, textarea:focus, select:focus {
  background: #333;
  border-color: #4caf50;
  box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
}

input[type="text"], input[type="number"], textarea {
  width: 200px;
  max-width: 100%;
}
button {
  cursor: pointer;
  background: #444;
  transition: 0.2s;
  padding: 10px 15px;
}
button:hover {
  background: #666;
}
#container {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 20px;
}
#effectList {
  max-width: 400px;
  margin: 10px;
}
.effect-item {
  border: 1px solid #555;
  padding: 10px;
  margin: 8px 0;
  border-radius: 5px;
  background: #222;
  cursor: move;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.2s;
}
.effect-item:hover {
  background: #333;
  transform: translateY(-2px);
}
.effect-item.dragging {
  opacity: 0.5;
  transform: rotate(5deg);
}
#canvasContainer {
  position: relative;
  margin: 10px auto;
  border: 2px solid #555;
  background: #000;
  border-radius: 8px;
}
#fireworkCanvas {
  cursor: crosshair;
  display: block;
  border-radius: 6px;
}
.tooltip {
  position: relative;
  display: inline-block;
}
.tooltip .tooltiptext {
  visibility: hidden;
  width: 200px;
  background: #333;
  color: #fff;
  text-align: left;
  border-radius: 5px;
  padding: 8px;
  position: absolute;
  z-index: 1;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
#timerDisplay {
  font-size: 3em;
  text-align: center;
  margin: 20px 0;
  font-weight: bold;
  color: #0ff;
}
#currentEffect {
  font-size: 1.4em;
  color: #ff0;
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #222;
  border-radius: 5px;
  min-height: 60px;
}
#warning {
  font-size: 2.5em;
  color: #f00;
  text-align: center;
  margin: 15px 0;
  font-weight: bold;
}
#timelineDisplay {
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #222;
  border-radius: 5px;
}
#printArea {
  display: none;
}
#warningFlash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: red;
  opacity: 0;
  pointer-events: none;
  border-radius: 5px;
  transition: opacity 0.1s;
}
.controls {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #222;
  border-radius: 8px;
}
.effect-delete {
  background: #d32f2f;
  color: white;
  border: none;
  padding: 5px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
}
.effect-delete:hover {
  background: #b71c1c;
}
#costCalculation {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #1a4d1a;
  border: 2px solid #2e7d32;
  border-radius: 8px;
}
#costCalculation h3 {
  margin: 0 0 10px 0;
  color: #4caf50;
}
#totalCost {
  font-size: 1.5em;
  font-weight: bold;
  color: #81c784;
}
#effectCount {
  color: #a5d6a7;
  margin-top: 5px;
}
.explosion {
  position: absolute;
  pointer-events: none;
  border-radius: 50%;
  animation: explode 1s ease-out forwards;
}
@keyframes explode {
  0% { transform: scale(0); opacity: 1; }
  50% { transform: scale(1.5); opacity: 0.8; }
  100% { transform: scale(3); opacity: 0; }
}
#qrModal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.8);
}
.modal-content {
  background-color: #222;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #555;
  border-radius: 10px;
  width: 300px;
  text-align: center;
}
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}
.close:hover {
  color: #fff;
}
#backupStatus {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #4caf50;
  color: white;
  padding: 10px;
  border-radius: 5px;
  display: none;
  z-index: 1000;
}
#effectOverview {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #1a1a2e;
  border: 2px solid #16213e;
  border-radius: 8px;
}
#effectOverview h3 {
  margin: 0 0 15px 0;
  color: #0f3460;
}
#overviewTable {
  overflow-x: auto;
}
.overview-table {
  width: 100%;
  border-collapse: collapse;
  background: #222;
  border-radius: 5px;
  overflow: hidden;
}
.overview-table th {
  background: #333;
  color: #fff;
  padding: 10px 8px;
  text-align: left;
  font-size: 12px;
  border-bottom: 2px solid #555;
}
.overview-table td {
  padding: 8px;
  border-bottom: 1px solid #444;
  font-size: 11px;
  color: #ddd;
}
.overview-table tr:hover {
  background: #2a2a2a;
}
.time-cell {
  color: #4caf50;
  font-weight: bold;
}
.channel-cell {
  color: #2196f3;
  font-weight: bold;
}
.button-cell {
  color: #ff9800;
  font-weight: bold;
}
.database-info {
  background: #2a2a2a;
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
  font-size: 12px;
  color: #ccc;
}
.image-preview {
  max-width: 200px;
  max-height: 150px;
  border-radius: 5px;
  border: 2px solid #555;
  margin: 10px 0;
}
.effect-image {
  max-width: 50px;
  max-height: 50px;
  border-radius: 3px;
  margin-right: 10px;
  vertical-align: middle;
}
.database-item {
  display: flex;
  align-items: center;
  padding: 5px;
  margin: 2px 0;
  background: #333;
  border-radius: 3px;
}
.database-item img {
  margin-right: 10px;
}
</style>
</head>
<body>

<h1>üéÜ FirePlanner 2D - Pro</h1>

<div id="planScreen">
<h2>Show-Name</h2>
<input id="showName" placeholder="Name der Show">

<h2>Effekt hinzuf√ºgen</h2>
<select id="effectSavedList" onchange="selectSavedEffect()">
  <option value="">Vorherige Effekte</option>
</select>
<div style="position: relative; display: inline-block;">
  <select id="effectDatabase" onchange="selectFromDatabase()">
    <option value="">Effekt-Datenbank</option>
  </select>
  <input type="text" id="effectSearch" placeholder="üîç Effekt suchen..." 
         style="display: none; position: absolute; top: 0; left: 0; width: 100%; z-index: 10;"
         onkeyup="searchEffects()" onblur="hideSearch()">
</div>
<button onclick="showSearch()" id="searchButton" style="display: none;">üîç Suchen</button><br>

<div class="database-info">
  üìä <strong>Excel-Import Format:</strong> Name | Barcode | Dauer | Preis | Typ<br>
  Beispiel: "Goldener Regen | 4260123456789 | 0:15 | 12.50 | rocket"<br>
  üì∏ <strong>Bilder:</strong> Optional - k√∂nnen einzeln hochgeladen werden
</div>

<h3>üì∏ Bild f√ºr Effekt (Optional)</h3>
<input type="file" id="effectImage" accept="image/*" onchange="previewImage()">
<div id="imagePreview" style="margin: 10px 0;"></div>
<button onclick="clearImage()">üóëÔ∏è Bild entfernen</button>

<input id="name" placeholder="Effektname">
<select id="effectType">
  <option value="rocket">Rakete</option>
  <option value="fountain">Font√§ne</option>
  <option value="battery">Batterie</option>
</select>
<input id="plannedDuration" placeholder="Dauer (m:s)">
<input id="price" placeholder="Preis (‚Ç¨)" type="number" step="0.01">
<input id="barcode" placeholder="Barcode/EAN">
<input id="time" placeholder="Showzeit (m:s)">

<select id="boxSelect" onchange="updateChannelSelect()">
    <option value="">Box w√§hlen (Empf√§nger)</option>
</select>
<select id="channelSelect" disabled>
    <option value="">Kanal w√§hlen</option>
</select>
<input id="buttonKey" placeholder="Taste">
<input id="quantity" placeholder="Anzahl Effekte">
<textarea id="additionalInfo" placeholder="Zusatzinfos"></textarea>
<button onclick="addEffect()">Effekt speichern</button>
<button onclick="addToDatabase()">Zur Datenbank hinzuf√ºgen</button>

<input type="file" id="excelImport" accept=".csv,.txt,.tsv" onchange="importExcelDatabase()">
<button onclick="document.getElementById('excelImport').click()">üìä Excel-Datenbank importieren</button>
<button onclick="clearDatabase()">üóëÔ∏è Datenbank leeren</button>
<button onclick="exportDatabase()">üíæ Datenbank exportieren (JSON)</button>
<input type="file" id="importDatabaseFile" accept=".json" onchange="importDatabase()" style="display: none;">
<button onclick="document.getElementById('importDatabaseFile').click()">üìÇ Datenbank importieren (JSON)</button>


<div id="boxControls" style="margin-top: 20px; padding: 15px; background: #2a2a2a; border-radius: 8px; border: 1px solid #444;">
    <h3>üì¶ Boxen & Kan√§le</h3>
    <input id="boxName" placeholder="Box-Name (z.B. Box A)" style="width: 150px;">
    <input id="boxChannels" placeholder="Kanalanzahl (z.B. 16)" type="number" min="1" value="16" style="width: 150px;">
    <button onclick="addBox()" style="background: #0f3460;">Box hinzuf√ºgen & speichern</button>
    <button onclick="clearBoxes()" style="background: #b71c1c;">üóëÔ∏è Alle Boxen leeren</button>
    <div id="boxList" style="margin-top: 10px; font-size: 14px; color: #aaa;"></div>
</div>
<div id="container">
  <div id="canvasContainer">
    <canvas id="fireworkCanvas" width="800" height="500"></canvas>
    <div id="warningFlash"></div>
  </div>
  <div id="effectList"></div>
</div>

<div id="costCalculation">
  <h3>üí∞ Kostenkalkulation</h3>
  <div id="totalCost">Gesamtkosten: 0,00 ‚Ç¨</div>
  <div id="effectCount">Anzahl Effekte: 0</div>
</div>

<div id="effectOverview">
  <h3>üìã Effekt-√úbersicht</h3>
  <div id="overviewTable"></div>
</div>

<h2>Musik</h2>
<input type="file" id="musicFile" accept="audio/*" onchange="loadMusic()">

<div class="controls">
<button onclick="saveShow()">Show speichern</button>
<button onclick="loadSavedShows()">Show laden</button>
<select id="savedShows" onchange="selectShow()">
  <option value="">Gespeicherte Shows</option>
</select>
<button onclick="exportShow()">Export JSON</button>
<input type="file" id="importFile" accept=".json" onchange="importShow()">
<button onclick="importShow()">Import JSON</button>
<button onclick="printPlan()">Druckversion</button>
<button onclick="generateQRCode()">üì± Smartphone-Steuerung</button>
<button onclick="loadFromSession()">üîó Session laden</button>
<button onclick="autoBackup()">üíæ Auto-Backup</button>
<button onclick="startShow()">Show starten</button>
<button onclick="pauseShow()">Pause</button>
<button onclick="resumeShow()">Fortsetzen</button>
<button onclick="stopShow()">Stopp</button>
    <button onclick="githubBackup()">‚òÅÔ∏è GitHub-Backup hochladen</button>
    <button onclick="githubRestore()">‚òÅÔ∏è GitHub-Backup laden</button>

</div>
</div>

<div id="showScreen" style="display:none;">
<h2>Show Timer</h2>
<div id="timerDisplay">00:00</div>
<div id="warning"></div>
<div id="currentEffect"></div>
<div id="timelineDisplay"></div>
<button onclick="backToPlan()" style="margin: 20px;">Zur√ºck zur Planung</button>
</div>

<div class="print-area" id="printArea"></div>

<div id="qrModal">
  <div class="modal-content">
    <span class="close" onclick="closeQRModal()">&times;</span>
    <h3>üì± Smartphone-Steuerung</h3>
    <div id="qrCode"></div>
    <p>Scanne den QR-Code mit deinem Smartphone</p>
    <div id="remoteUrl"></div>
  </div>
</div>

<div id="backupStatus">Backup erstellt!</div>

<audio id="warningBeep" preload="auto">
  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
</audio>
<audio id="fireBeep" preload="auto">
  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N0QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
</audio>
<audio id="musicPlayer"></audio>

<script>
let effects = [];
let showTimer = null;
let showStartTime = 0;
let isPaused = false;
let pausedTime = 0;
let canvas, ctx;
let savedEffects = [];
let effectDatabase = [];
let draggedEffect = null;
let autoBackupInterval = null;
let currentEffectImage = null;
let firingBoxes = []; // NEU: Globale Variable f√ºr die Boxen

// =================================================================================
// NEUE FUNKTIONEN F√úR Z√úND-SIGNALTON, TIMELINE UND EXPLOSION
// =================================================================================

/**
 * Spielt den Signalton beim Z√ºnden eines Effekts ab. (Anforderung: Signalton beim Z√ºnden)
 */
function playFireBeep() {
  const audio = document.getElementById('fireBeep');
  if (audio) {
    // Klonen, um √ºberlappende Z√ºndungen zu erm√∂glichen
    const clone = audio.cloneNode();
    clone.currentTime = 0; 
    clone.play().catch(e => console.error("Fehler beim Abspielen des Z√ºnd-Signals:", e));
  }
}

/**
 * Spielt ein Best√§tigungs-Signal ab (f√ºr Import/Export der Datenbank). (Anforderung: Signalton beim Exportieren/Importieren)
 */
function playSuccessBeep() {
    const audio = document.getElementById('fireBeep'); // Reuse the fireBeep sound for success confirmation
    if (audio) {
        const clone = audio.cloneNode();
        clone.currentTime = 0;
        clone.volume = 0.5; // Slightly quieter for confirmation
        clone.play().catch(e => console.error("Fehler beim Abspielen des DB-Signals:", e));
    }
}

/**
 * Erzeugt eine kurze, visuelle Explosion auf dem Canvas (simuliert Z√ºndung).
 */
function triggerExplosion(x, y, type) {
  const container = document.getElementById('canvasContainer');
  const explosion = document.createElement('div');
  explosion.className = 'explosion';
  
  // Positionierung im Canvas-Container
  explosion.style.top = `${y}px`;
  explosion.style.left = `${x}px`;
  
  let color = '#fff';
  if (type === 'rocket') color = '#ff3333'; // Rot
  if (type === 'fountain') color = '#33ff33'; // Gr√ºn
  if (type === 'battery') color = '#3399ff'; // Blau

  explosion.style.backgroundColor = color;
  explosion.style.width = '10px';
  explosion.style.height = '10px';
  
  container.appendChild(explosion);
  
  // Element nach der Animation entfernen (1000ms entspricht CSS-keyframes)
  setTimeout(() => {
    if(container.contains(explosion)) {
        container.removeChild(explosion);
    }
  }, 1000);
}

/**
 * Aktualisiert die Anzeige der n√§chsten Effekte in der Timeline. (Anforderung: Z√ºnd-Timeline)
 */
function updateTimelineDisplay(currentTime) {
  const display = document.getElementById('timelineDisplay');
  let timelineHTML = '<h3>N√§chste Effekte (Timeline):</h3><ul>';

  // 1. Filtere Effekte, die noch nicht gez√ºndet wurden
  const upcomingEffects = effects
    .filter(e => !e.fired)
    .sort((a, b) => a.time - b.time);

  // 2. Zeige die n√§chsten 5 an
  upcomingEffects.slice(0, 5).forEach(effect => {
    const timeToFire = effect.time - currentTime;
    timelineHTML += `<li><strong>${effect.timeStr}</strong> (in ${Math.max(0, timeToFire).toFixed(1)}s): ${effect.name} (Box: ${effect.receiver || '-'}, Kanal: ${effect.channel || '-'})</li>`;
  });

  if (upcomingEffects.length === 0 && effects.length > 0) {
      timelineHTML += '<li><em style="color:#aaa;">Alle Effekte gez√ºndet.</em></li>';
  } else if (effects.length === 0) {
      timelineHTML += '<li><em style="color:#aaa;">Keine Effekte in der Show.</em></li>';
  }

  timelineHTML += '</ul>';

  // 3. Zeige den aktuell z√ºndenden Effekt
  const firingEffects = effects.filter(e => e.status === 'firing');
  if (firingEffects.length > 0) {
      firingEffects.forEach(effect => {
          const durationSec = parseTime(effect.plannedDuration);
          const durationLeft = effect.time + durationSec - currentTime;
          
          timelineHTML = `
            <h3>üî• Aktiver Effekt: ${effect.name}</h3>
            <p style="color:#ff0; font-weight: bold;">Verbleibende Dauer: ${formatTime(Math.max(0, durationLeft))}</p>
          ` + timelineHTML;
      });
  }

  display.innerHTML = timelineHTML;
}


// Initialize canvas and load data
window.onload = function() {
  canvas = document.getElementById('fireworkCanvas');
  ctx = canvas.getContext('2d');
  loadSavedShows();
  loadSavedEffects();
  loadEffectDatabase();
  loadFiringBoxes(); // NEU: Boxen beim Laden initialisieren
  drawCanvas();
  startAutoBackup();
  
  // Canvas click handler
  canvas.addEventListener('click', function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Finde nicht platzierte Effekte
    const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);
    
    if (unplacedEffects.length > 0) {
      const effectToPlace = unplacedEffects[0];
      effectToPlace.x = x;
      effectToPlace.y = y;
      updateEffectList();
      drawCanvas();
      
      // Zeige Best√§tigung
      const tempMsg = document.createElement('div');
      tempMsg.style.cssText = `
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background: #4caf50; color: white; padding: 10px 20px;
        border-radius: 5px; z-index: 1000; font-weight: bold;
      `;
      tempMsg.textContent = `‚úÖ "${effectToPlace.name}" platziert!`;
      document.body.appendChild(tempMsg);
      
      setTimeout(() => {
        if (tempMsg.parentNode) {
          tempMsg.parentNode.removeChild(tempMsg);
        }
      }, 2000);
    }
  });
  
  // Drag and drop for canvas
  canvas.addEventListener('dragover', function(e) {
    e.preventDefault();
  });
  
  canvas.addEventListener('drop', function(e) {
    e.preventDefault();
    if (draggedEffect) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      draggedEffect.x = x;
      draggedEffect.y = y;
      updateEffectList();
      drawCanvas();
      draggedEffect = null;
    }
  });
};

// Image handling functions
function previewImage() {
  const fileInput = document.getElementById('effectImage');
  const file = fileInput.files[0];
  const previewDiv = document.getElementById('imagePreview');
  
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      currentEffectImage = e.target.result;
      previewDiv.innerHTML = `<img src="${currentEffectImage}" class="image-preview" alt="Effekt Vorschau">`;
    };
    reader.readAsDataURL(file);
  } else {
    clearImage();
  }
}

function clearImage() {
  currentEffectImage = null;
  document.getElementById('imagePreview').innerHTML = '';
  document.getElementById('effectImage').value = '';
}

function initializeDatabase() {
  // Diese Funktion wird nur noch f√ºr manuelle Initialisierung verwendet
  // Keine automatischen Beispiel-Effekte mehr!
  console.log('‚ö†Ô∏è initializeDatabase() aufgerufen - sollte nicht automatisch passieren!');
  
  const sampleEffects = [
    {name: "Goldener Regen", duration: "0:15", price: 12.50, barcode: "4260123456789", effectType: "fountain"},
    {name: "Silber Rakete", duration: "0:03", price: 8.90, barcode: "4260123456790", effectType: "rocket"},
    {name: "Bunte Batterie", duration: "0:45", price: 25.00, barcode: "4260123456791", effectType: "battery"},
    {name: "Rote Sterne", duration: "0:08", price: 15.20, barcode: "4260123456792", effectType: "rocket"},
    {name: "Gr√ºne Font√§ne", duration: "0:20", price: 18.75, barcode: "4260123456793", effectType: "fountain"}
  ];
  
  effectDatabase = sampleEffects;
  localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
  updateDatabaseList();
  console.log('‚úÖ Beispiel-Datenbank manuell erstellt');
}

function loadEffectDatabase() {
  console.log('üîß Lade Effekt-Datenbank...');
  
  const saved = localStorage.getItem('effectDatabase');
  if (saved) {
    try {
      const parsedDatabase = JSON.parse(saved);
      console.log('‚úÖ Datenbank aus LocalStorage geladen:', parsedDatabase.length, 'Effekte');
      console.log('üìã Geladene Effekte:', parsedDatabase);
      
      // Validiere Datenbank-Struktur
      if (!Array.isArray(parsedDatabase)) {
        console.error('‚ùå Datenbank ist kein Array, erstelle leere Datenbank...');
        effectDatabase = [];
        localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
        updateDatabaseList();
        return;
      }
      
      // Setze die Datenbank - auch wenn sie leer ist!
      effectDatabase = parsedDatabase;
      console.log('‚úÖ Datenbank erfolgreich geladen, aktualisiere Dropdown...');
      updateDatabaseList();
      
      // Zeige Status-Meldung
      if (effectDatabase.length === 0) {
        console.log('‚ÑπÔ∏è Datenbank ist leer - das ist OK!');
      } else {
        console.log(`‚úÖ ${effectDatabase.length} Effekte erfolgreich geladen`);
        // Zeige die ersten paar Effekte zur Best√§tigung
        effectDatabase.slice(0, 3).forEach((effect, i) => {
          console.log(`${i + 1}. ${effect.name} - ${effect.addedDate ? new Date(effect.addedDate).toLocaleString() : 'Kein Datum'}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Datenbank:', error);
      console.log('üîß Erstelle leere Datenbank wegen Fehler...');
      effectDatabase = [];
      localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
      updateDatabaseList();
      return;
    }
  } else {
    console.log('üîß Keine Datenbank gefunden, erstelle leere Datenbank...');
    effectDatabase = [];
    localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
    updateDatabaseList();
    console.log('‚úÖ Leere Datenbank erstellt');
  }
}

function updateDatabaseList() {
  console.log('üîß Starte Dropdown-Aktualisierung...');
  
  const select = document.getElementById('effectDatabase');
  
  if (!select) {
    console.error('‚ùå Dropdown-Element "effectDatabase" nicht gefunden!');
    return;
  }
  
  console.log(`üìä Aktualisiere Dropdown mit ${effectDatabase.length} Effekten`);
  
  // Zeige aktuellen Datenbank-Status in der Konsole
  console.log('üìã Aktuelle Datenbank-Inhalte:');
  if (effectDatabase.length === 0) {
    console.log('üìù Datenbank ist leer');
  } else {
    effectDatabase.forEach((effect, index) => {
      console.log(`${index + 1}. ${effect.name} - ${effect.price || 0}‚Ç¨ - ${effect.barcode || 'Kein Barcode'} - ${effect.addedDate ? new Date(effect.addedDate).toLocaleString() : 'Kein Datum'}`);
    });
  }
  
  // Pr√ºfe LocalStorage-Konsistenz
  const stored = localStorage.getItem('effectDatabase');
  if (stored) {
    try {
      const storedDatabase = JSON.parse(stored);
      if (storedDatabase.length !== effectDatabase.length) {
        console.warn('‚ö†Ô∏è WARNUNG: LocalStorage und Variable sind inkonsistent!');
        console.warn('Variable:', effectDatabase.length, 'LocalStorage:', storedDatabase.length);
      } else {
        console.log('‚úÖ LocalStorage und Variable sind konsistent');
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Pr√ºfen des LocalStorage:', error);
    }
  }
  
  // Performance-optimierte Aktualisierung f√ºr gro√üe Datenbanken
  if (effectDatabase.length > 100) {
    console.log('‚ö° Verwende Performance-Modus f√ºr gro√üe Datenbank');
    
    // Zeige Suchbutton f√ºr gro√üe Datenbanken
    const searchButton = document.getElementById('searchButton');
    if (searchButton) {
      searchButton.style.display = 'inline-block';
    }
    
    // Leere das Dropdown
    select.innerHTML = '';
    
    // Standard-Option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = `üìä Datenbank (${effectDatabase.length} Effekte) - Suchbutton nutzen`;
    select.appendChild(defaultOption);
    
    // Nur erste 20 Effekte laden f√ºr bessere Performance
    const maxDisplay = Math.min(20, effectDatabase.length);
    
    for (let i = 0; i < maxDisplay; i++) {
      const effect = effectDatabase[i];
      const option = document.createElement('option');
      option.value = i.toString();
      
      // Sehr kurze Anzeige f√ºr Performance
      const price = (effect.price && effect.price > 0) ? ` ${effect.price}‚Ç¨` : '';
      const shortName = effect.name.length > 20 ? effect.name.substring(0, 20) + '...' : effect.name;
      
      option.textContent = `${shortName}${price}`;
      select.appendChild(option);
    }
    
    if (effectDatabase.length > maxDisplay) {
      const moreOption = document.createElement('option');
      moreOption.value = 'search';
      moreOption.textContent = `... ${effectDatabase.length - maxDisplay} weitere ‚Üí Suchbutton nutzen`;
      moreOption.disabled = true;
      select.appendChild(moreOption);
    }
    
  } else {
    // Normale Aktualisierung f√ºr kleinere Datenbanken
    // Verstecke Suchbutton f√ºr kleine Datenbanken
    const searchButton = document.getElementById('searchButton');
    if (searchButton) {
      searchButton.style.display = 'none';
    }
    
    select.innerHTML = '';
    
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = `üìä Effekt-Datenbank (${effectDatabase.length} Effekte)`;
    select.appendChild(defaultOption);
    
    effectDatabase.forEach((effect, index) => {
      const option = document.createElement('option');
      option.value = index.toString();
      
      const price = (effect.price && effect.price > 0) ? `${effect.price}‚Ç¨` : '';
      const duration = effect.duration || effect.plannedDuration || '';
      const type = effect.effectType || effect.type || '';
      const hasImage = effect.image ? 'üì∏ ' : '';
      
      option.textContent = `${hasImage}${effect.name} ${price ? '- ' + price : ''} ${duration ? '- ' + duration : ''} ${type ? '- ' + type : ''}`;
      select.appendChild(option);
    });
  }
  
  console.log('‚úÖ Dropdown aktualisiert!');
}

function selectFromDatabase() {
  const select = document.getElementById('effectDatabase');
  const selectedValue = select.value;
  
  console.log('üîç Datenbank-Auswahl gestartet:', {
    selectedValue: selectedValue,
    databaseLength: effectDatabase.length,
    database: effectDatabase
  });
  
  // Pr√ºfe ob ein Wert ausgew√§hlt wurde
  if (!selectedValue || selectedValue === '') {
    console.log('‚ÑπÔ∏è Keine Auswahl getroffen');
    return;
  }
  
  const index = parseInt(selectedValue);
  console.log('üî¢ Index berechnet:', index);
  
  // Validiere Index
  if (isNaN(index) || index < 0 || index >= effectDatabase.length) {
    console.error('‚ùå Ung√ºltiger Index:', {
      originalValue: selectedValue,
      parsedIndex: index,
      isNaN: isNaN(index),
      tooSmall: index < 0,
      tooLarge: index >= effectDatabase.length,
      databaseLength: effectDatabase.length
    });
    alert(`‚ùå Fehler: Ung√ºltiger Index ${index} f√ºr Datenbank mit ${effectDatabase.length} Eintr√§gen!`);
    return;
  }
  
  const effect = effectDatabase[index];
  console.log('üìã Effekt gefunden:', effect);
  
  if (!effect) {
    console.error('‚ùå Effekt nicht gefunden bei Index:', index);
    alert('‚ùå Effekt nicht gefunden!');
    return;
  }
  
  try {
    // Felder f√ºllen mit Validierung
    const fields = {
      name: document.getElementById('name'),
      effectType: document.getElementById('effectType'),
      plannedDuration: document.getElementById('plannedDuration'),
      price: document.getElementById('price'),
      barcode: document.getElementById('barcode')
    };
    
    // Pr√ºfe ob alle Felder existieren
    for (const [fieldName, field] of Object.entries(fields)) {
      if (!field) {
        console.error(`‚ùå Feld ${fieldName} nicht gefunden!`);
        alert(`‚ùå Eingabefeld ${fieldName} nicht gefunden!`);
        return;
      }
    }
    
    // F√ºlle die Felder
    fields.name.value = effect.name || '';
    fields.effectType.value = effect.effectType || effect.type || 'rocket';
    fields.plannedDuration.value = effect.duration || effect.plannedDuration || '';
    fields.price.value = effect.price || '';
    fields.barcode.value = effect.barcode || '';
    
    console.log('‚úÖ Felder gef√ºllt:', {
      name: fields.name.value,
      type: fields.effectType.value,
      duration: fields.plannedDuration.value,
      price: fields.price.value,
      barcode: fields.barcode.value
    });
    
    // Load image if available
    if (effect.image) {
      currentEffectImage = effect.image;
      const previewDiv = document.getElementById('imagePreview');
      if (previewDiv) {
        previewDiv.innerHTML = `<img src="${currentEffectImage}" class="image-preview" alt="Effekt Bild">`;
        console.log('üì∏ Bild geladen');
      }
    } else {
      clearImage();
      console.log('üö´ Kein Bild vorhanden');
    }
    
    // Visuelles Feedback - gr√ºnes Aufleuchten
    fields.name.style.background = '#2d5a2d';
    fields.name.style.borderColor = '#4caf50';
    fields.name.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
    
    setTimeout(() => {
      fields.name.style.background = '#222';
      fields.name.style.borderColor = '#555';
      fields.name.style.boxShadow = 'none';
    }, 2000);
    
    // Success message
    const imageText = effect.image ? ' üì∏' : '';
    const priceText = effect.price ? ` - ${effect.price}‚Ç¨` : '';
    
    console.log(`‚úÖ Effekt "${effect.name}"${imageText}${priceText} erfolgreich geladen!`);
    
    // Show temporary success message
    const tempMsg = document.createElement('div');
    tempMsg.style.cssText = `
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: #4caf50; color: white; padding: 15px 25px;
      border-radius: 8px; z-index: 1000; font-weight: bold;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    tempMsg.textContent = `‚úÖ "${effect.name}" aus Datenbank geladen!${imageText}`;
    document.body.appendChild(tempMsg);
    
    setTimeout(() => {
      if (tempMsg.parentNode) {
        tempMsg.parentNode.removeChild(tempMsg);
      }
    }, 3000);
    
  } catch (error) {
    console.error('‚ùå Fehler beim Laden des Effekts:', error);
    alert('‚ùå Fehler beim Laden des Effekts: ' + error.message);
  }
}

function addToDatabase() {
  const name = document.getElementById('name').value;
  const effectType = document.getElementById('effectType').value;
  const duration = document.getElementById('plannedDuration').value;
  const price = parseFloat(document.getElementById('price').value) || 0;
  const barcode = document.getElementById('barcode').value;
  
  if (!name) {
    alert('Bitte mindestens Name eingeben!');
    return;
  }
  
  const newEffect = {
    name, 
    effectType, 
    duration, 
    price, 
    barcode,
    image: currentEffectImage, // Add image if available
    addedDate: new Date().toISOString() // Zeitstempel hinzuf√ºgen
  };
  
  console.log('üíæ F√ºge Effekt zur Datenbank hinzu:', newEffect);
  console.log('üìä Datenbank vor dem Hinzuf√ºgen:', effectDatabase.length, 'Effekte');
  
  // Pr√ºfe LocalStorage vor dem Hinzuf√ºgen
  const beforeStorage = localStorage.getItem('effectDatabase');
  console.log('üìã LocalStorage vor √Ñnderung:', beforeStorage ? JSON.parse(beforeStorage).length : 0, 'Effekte');
  
  effectDatabase.push(newEffect);
  console.log('üìä Datenbank nach dem Hinzuf√ºgen:', effectDatabase.length, 'Effekte');
  
  // Speichere mit umfassender Validierung
  try {
    const jsonString = JSON.stringify(effectDatabase);
    console.log('üíæ Speichere JSON-String mit', jsonString.length, 'Zeichen');
    
    localStorage.setItem('effectDatabase', jsonString);
    console.log('üíæ LocalStorage.setItem() ausgef√ºhrt');
    
    // Sofortige Verifikation der Speicherung
    const verification = localStorage.getItem('effectDatabase');
    if (verification) {
      const parsed = JSON.parse(verification);
      console.log('‚úÖ Speicherung verifiziert:', parsed.length, 'Effekte im LocalStorage');
      
      // Pr√ºfe ob der neue Effekt wirklich drin ist
      const lastEffect = parsed[parsed.length - 1];
      if (lastEffect && lastEffect.name === name && lastEffect.addedDate === newEffect.addedDate) {
        console.log('‚úÖ Neuer Effekt erfolgreich gespeichert:', lastEffect.name);
        console.log('üìã Effekt-Details:', lastEffect);
        console.log('üïí Hinzugef√ºgt am:', new Date(lastEffect.addedDate).toLocaleString());
      } else {
        console.error('‚ùå KRITISCHER FEHLER: Neuer Effekt nicht korrekt in LocalStorage!');
        console.error('Erwartet:', name, 'mit Datum:', newEffect.addedDate);
        console.error('Gefunden:', lastEffect ? lastEffect.name : 'nichts', 'mit Datum:', lastEffect ? lastEffect.addedDate : 'kein Datum');
        alert('‚ùå KRITISCHER FEHLER: Effekt wurde nicht korrekt gespeichert!');
        return;
      }
      
      // Zus√§tzliche Konsistenz-Pr√ºfung
      if (parsed.length !== effectDatabase.length) {
        console.error('‚ùå INKONSISTENZ: LocalStorage und Variable haben unterschiedliche L√§ngen!');
        console.error('Variable:', effectDatabase.length, 'LocalStorage:', parsed.length);
        alert('‚ùå WARNUNG: Inkonsistenz zwischen Speicher und Variable!');
      } else {
        console.log('‚úÖ Variable und LocalStorage sind konsistent');
      }
    } else {
      console.error('‚ùå KRITISCHER FEHLER: Nichts im LocalStorage gespeichert!');
      alert('‚ùå KRITISCHER FEHLER: Speicherung fehlgeschlagen - LocalStorage leer!');
      return;
    }
  } catch (error) {
    console.error('‚ùå Fehler beim Speichern des Effekts:', error);
    console.error('‚ùå Error Stack:', error.stack);
    alert('‚ùå Fehler beim Speichern! M√∂glicherweise ist der Browser-Speicher voll.\n\nFehler: ' + error.message);
    return;
  }
  
  updateDatabaseList();
  
  const imageText = currentEffectImage ? ' (mit Bild)' : '';
  alert(`‚úÖ Effekt "${name}"${imageText} zur Datenbank hinzugef√ºgt!\n\nüìä Datenbank hat jetzt ${effectDatabase.length} Effekte.\nüïí Hinzugef√ºgt: ${new Date().toLocaleString()}`);
  
  // Clear form after adding
  clearImage();
}

function clearDatabase() {
  if (confirm('Wirklich die komplette Datenbank l√∂schen?\nDies kann nicht r√ºckg√§ngig gemacht werden!')) {
    effectDatabase = [];
    localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
    updateDatabaseList();
    console.log('‚úÖ Datenbank geleert - bleibt leer bis neue Effekte hinzugef√ºgt werden');
    alert('Datenbank geleert! Sie bleibt leer bis Sie neue Effekte hinzuf√ºgen.');
  }
}

// =================================================================================
// NEUE FUNKTIONEN F√úR DATENBANK IMPORT/EXPORT
// =================================================================================

/**
 * Exportiert die aktuelle Effekt-Datenbank als JSON-Datei. (Anforderung: Exportieren der Datenbank)
 */
function exportDatabase() {
    const db = localStorage.getItem('effectDatabase');
    if (!db || JSON.parse(db).length === 0) {
        alert('‚ùå Datenbank ist leer! Nichts zu exportieren.');
        return;
    }

    const data = JSON.parse(db);
    // Beinhaltet auch das Datum, falls es f√ºr den Import sp√§ter relevant ist
    const exportObject = {
        exportDate: new Date().toISOString(),
        effectDatabase: data
    };

    const dataStr = JSON.stringify(exportObject, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `fireplanner_database_export_${new Date().toISOString().substring(0, 10).replace(/-/g, '')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    
    playSuccessBeep(); // Signalton beim Exportieren
    alert('‚úÖ Datenbank erfolgreich exportiert!');
}

/**
 * Importiert eine JSON-Datei und l√§dt diese als neue Effekt-Datenbank. (Anforderung: Importieren der Datenbank)
 */
function importDatabase() {
    const fileInput = document.getElementById('importDatabaseFile');
    const file = fileInput.files[0];
    
    if (!file) {
        return; 
    }
    
    if (!confirm('Achtung: Die bestehende Datenbank wird √ºberschrieben! Fortfahren?')) {
        fileInput.value = ''; 
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            let importedData = JSON.parse(e.target.result);
            
            // Pr√ºfe auf das erweiterte Export-Format
            if (importedData.effectDatabase && Array.isArray(importedData.effectDatabase)) {
                importedData = importedData.effectDatabase;
            }
            
            if (Array.isArray(importedData)) {
                effectDatabase = importedData;
                localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
                updateDatabaseList();
                
                playSuccessBeep(); // Signalton beim Importieren
                alert(`‚úÖ Datenbank erfolgreich importiert! (${effectDatabase.length} Effekte)`);
            } else {
                alert('‚ùå Import-Fehler: Die Datei enth√§lt keine g√ºltige Effekte-Liste (kein Array).');
            }
        } catch (error) {
            alert(`‚ùå Import-Fehler: Ung√ºltiges JSON-Format.\n\nFehler: ${error.message}`);
        }
        fileInput.value = ''; // Clear file input
    };
    reader.onerror = function() {
        alert('‚ùå Fehler beim Lesen der Datei.');
        fileInput.value = '';
    };
    reader.readAsText(file);
}


function importExcelDatabase() {
  const fileInput = document.getElementById('excelImport');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Bitte eine Excel/CSV-Datei ausw√§hlen!');
    return;
  }
  
  console.log('üìä Starte Excel-Import...');
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const text = e.target.result;
      const lines = text.split('\n');
      const newEffects = [];
      let skippedLines = 0;
      let processedLines = 0;
      
      console.log(`üìã Verarbeite ${lines.length} Zeilen...`);
      
      // Verarbeite alle Zeilen (auch erste Zeile falls keine √úberschrift)
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line) {
          processedLines++;
          
          // Versuche verschiedene Trennzeichen: Tab, Semikolon, Komma, Pipe
          let columns = [];
          
          if (line.includes('\t')) {
            columns = line.split('\t');
          } else if (line.includes(';')) {
            columns = line.split(';');
          } else if (line.includes('|')) {
            columns = line.split('|');
          } else if (line.includes(',')) {
            columns = line.split(',');
          } else {
            // Fallback: Leerzeichen als Trenner
            columns = line.split(/\s+/);
          }
          
          // Bereinige Spalten von Anf√ºhrungszeichen
          columns = columns.map(col => col.trim().replace(/^["']|["']$/g, ''));
          
          console.log(`Zeile ${i + 1}: ${columns.length} Spalten:`, columns);
          
          if (columns.length >= 2) {
            // √úberspringe Kopfzeilen (enthalten oft "Name", "Barcode", etc.)
            const firstCol = columns[0].toLowerCase();
            if (firstCol.includes('name') || firstCol.includes('effekt') || firstCol.includes('artikel')) {
              console.log(`√úberspringe Kopfzeile: ${columns[0]}`);
              continue;
            }
            
            const effect = {
              name: columns[0] || `Effekt ${newEffects.length + 1}`,
              barcode: columns[1] || '',
              duration: columns[2] || '',
              price: columns[3] ? parseFloat(columns[3].replace(',', '.')) || 0 : 0,
              effectType: columns[4] || 'rocket'
            };
            
            // Validiere Mindestanforderungen
            if (effect.name && effect.name.length > 0) {
              newEffects.push(effect);
              console.log(`‚úÖ Effekt hinzugef√ºgt: ${effect.name}`);
            } else {
              skippedLines++;
              console.log(`‚ùå Zeile √ºbersprungen: Kein Name`);
            }
          } else {
            skippedLines++;
            console.log(`‚ùå Zeile √ºbersprungen: Zu wenige Spalten (${columns.length})`);
          }
        }
      }
      
      console.log(`üìä Import-Ergebnis: ${newEffects.length} neue Effekte, ${skippedLines} √ºbersprungen`);
      
      if (newEffects.length > 0) {
        // F√ºge neue Effekte zur bestehenden Datenbank hinzu
        const oldCount = effectDatabase.length;
        effectDatabase = effectDatabase.concat(newEffects);
        
        // Speichere in LocalStorage mit Validierung
        try {
          localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
          console.log('üíæ Datenbank erfolgreich gespeichert:', effectDatabase.length, 'Effekte');
          
          // Verifikation der Speicherung
          const verification = localStorage.getItem('effectDatabase');
          if (verification) {
            const parsed = JSON.parse(verification);
            console.log('‚úÖ Speicherung verifiziert:', parsed.length, 'Effekte');
          }
        } catch (error) {
          console.error('‚ùå Fehler beim Speichern der Datenbank:', error);
          alert('‚ùå Fehler beim Speichern der Datenbank! M√∂glicherweise ist der Speicher voll.');
          return;
        }
        
        // Aktualisiere UI
        updateDatabaseList();
        
        let message = `‚úÖ ${newEffects.length} Effekte erfolgreich importiert!\n`;
        message += `üìä Datenbank: ${oldCount} ‚Üí ${effectDatabase.length} Effekte\n`;
        if (skippedLines > 0) {
          message += `‚ö†Ô∏è ${skippedLines} von ${processedLines} Zeilen √ºbersprungen`;
        }
        
        alert(message);
        
        // Zeige erste paar importierte Effekte zur Kontrolle
        console.log('üéÜ Erste importierte Effekte:');
        newEffects.slice(0, 5).forEach((effect, i) => {
          console.log(`${i + 1}. ${effect.name} - ${effect.price}‚Ç¨ - ${effect.barcode}`);
        });
        
      } else {
        alert(`‚ùå Keine g√ºltigen Effekte gefunden!\n\nüìã Verarbeitete Zeilen: ${processedLines}\n‚ö†Ô∏è √úbersprungene Zeilen: ${skippedLines}\n\nüí° Format-Beispiele:\n‚Ä¢ Name;Barcode;Dauer;Preis;Typ\n‚Ä¢ Name|Barcode|Dauer|Preis|Typ\n‚Ä¢ Name,Barcode,Dauer,Preis,Typ`);
      }
    } catch (error) {
      console.error('‚ùå Import-Fehler:', error);
      alert(`‚ùå Fehler beim Importieren der Datei!\n\nFehler: ${error.message}\n\nüí° Tipps:\n‚Ä¢ Datei als UTF-8 speichern\n‚Ä¢ Trennzeichen: ; | , oder Tab\n‚Ä¢ Mindestens Name und Barcode`);
    }
  };
  reader.readAsText(file, 'UTF-8');
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  if (parts.length === 2) {
    return parseInt(parts[0]) * 60 + parseFloat(parts[1]); // Erlaube Sekunden mit Nachkommastelle
  }
  return parseFloat(timeStr) || 0;
}

function formatTime(seconds) {
  seconds = Math.max(0, seconds); // Ensure no negative time
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  // Format seconds to one decimal place if not an integer
  const secsStr = Number.isInteger(secs) ? secs.toString().padStart(2, '0') : secs.toFixed(1).padStart(4, '0');
  return `${mins.toString().padStart(2, '0')}:${secsStr}`;
}

function addEffect() {
  const name = document.getElementById('name').value;
  const effectType = document.getElementById('effectType').value;
  const plannedDuration = document.getElementById('plannedDuration').value;
  const price = parseFloat(document.getElementById('price').value) || 0;
  const barcode = document.getElementById('barcode').value;
  const time = document.getElementById('time').value;
  
  // NEU: Lesen aus den Select-Feldern
  const receiver = document.getElementById('boxSelect').value;
  const channel = document.getElementById('channelSelect').value;
  
  const buttonKey = document.getElementById('buttonKey').value;
  const quantity = parseInt(document.getElementById('quantity').value) || 1;
  const additionalInfo = document.getElementById('additionalInfo').value;
  
  if (!name || !time) {
    alert('Bitte mindestens Name und Showzeit eingeben!');
    return;
  }
  
  // NEUE FELDER hinzugef√ºgt: fired und status
  const effect = {
    id: Date.now(),
    name,
    effectType,
    plannedDuration,
    price,
    barcode,
    time: parseTime(time),
    timeStr: time,
    channel, // Liest jetzt den Kanal aus der Auswahl
    receiver, // Liest jetzt die Box (Empf√§nger) aus der Auswahl
    buttonKey,
    quantity,
    additionalInfo,
    image: currentEffectImage, // Add image if available
    x: null, // Muss manuell platziert werden
    y: null,
    fired: false, // NEU: Status, ob Effekt bereits gez√ºndet wurde
    status: 'planned' // NEU: Status: 'planned', 'firing', 'finished'
  };
  
  effects.push(effect);
  
  // Save to saved effects (Boxname ist jetzt der Empf√§nger)
  if (!savedEffects.find(e => e.name === name)) {
    // Speichert Boxname/Kanal f√ºr die Vorlagen
    savedEffects.push({ name, effectType, plannedDuration, price, barcode, boxName: receiver, channel, buttonKey, quantity, additionalInfo });
    localStorage.setItem('savedEffects', JSON.stringify(savedEffects));
    updateSavedEffectsList();
  }
  
  // Clear form
  document.getElementById('name').value = '';
  document.getElementById('plannedDuration').value = '';
  document.getElementById('price').value = '';
  document.getElementById('barcode').value = '';
  document.getElementById('time').value = '';
  // Setze Boxen-Auswahl zur√ºck
  document.getElementById('boxSelect').value = '';
  document.getElementById('channelSelect').value = '';
  updateChannelSelect(); // Kanal-Auswahl leeren/deaktivieren
  document.getElementById('buttonKey').value = '';
  document.getElementById('quantity').value = '';
  document.getElementById('additionalInfo').value = '';
  clearImage(); // Clear image as well
  
  updateEffectList();
  updateCostCalculation();
  drawCanvas();
}

function updateEffectList() {
  const list = document.getElementById('effectList');
  list.innerHTML = '<h3>Effekte in der Show</h3>';
  effects.sort((a, b) => a.time - b.time);
  effects.forEach(effect => {
    const div = document.createElement('div');
    div.className = 'effect-item';
    div.draggable = true;
    
    // Farbcodes f√ºr Status
    let statusColor = '#222';
    if (effect.status === 'firing') statusColor = '#5c4000'; // Orange f√ºr Z√ºndung
    if (effect.status === 'finished') statusColor = '#1a4d1a'; // Gr√ºn f√ºr beendet
    
    div.style.backgroundColor = statusColor;

    div.innerHTML = `
      <div style="display: flex; align-items: center;">
        ${effect.image ? `<img src="${effect.image}" class="effect-image" alt="Effekt">` : ''}
        <div>
          <strong>${effect.name}</strong><br>
          Zeit: ${effect.timeStr} | Typ: ${effect.effectType}<br>
          Box: ${effect.receiver || 'Nicht gesetzt'} | Kanal: ${effect.channel || 'Nicht gesetzt'} | Taste: ${effect.buttonKey || 'Nicht gesetzt'}<br>
          ${effect.price > 0 ? `Preis: ${effect.price.toFixed(2)}‚Ç¨ | ` : ''}Anzahl: ${effect.quantity}<br>
          Position: ${effect.x ? `X:${Math.round(effect.x)}, Y:${Math.round(effect.y)}` : 'Nicht platziert'}
        </div>
      </div>
      <div style="display: flex; gap: 5px;">
        <button class="effect-edit" onclick="editEffect(${effect.id})" style="background: #2196f3; color: white; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">‚úèÔ∏è</button>
        <button class="effect-delete" onclick="deleteEffect(${effect.id})">√ó</button>
      </div>
    `;
    // Add drag handlers
    div.addEventListener('dragstart', function(e) {
      draggedEffect = effect;
      div.classList.add('dragging');
    });
    div.addEventListener('dragend', function(e) {
      div.classList.remove('dragging');
    });
    list.appendChild(div);
  });
}

function updateCostCalculation() {
  let totalCost = 0;
  let totalEffects = 0;
  effects.forEach(effect => {
    totalCost += (effect.price || 0) * (effect.quantity || 1);
    totalEffects += effect.quantity || 1;
  });
  document.getElementById('totalCost').textContent = `Gesamtkosten: ${totalCost.toFixed(2)} ‚Ç¨`;
  document.getElementById('effectCount').textContent = `Anzahl Effekte: ${totalEffects}`;
  updateEffectOverview();
}

function updateEffectOverview() {
  const overviewDiv = document.getElementById('overviewTable');
  if (effects.length === 0) {
    overviewDiv.innerHTML = '<p style="color: #666; font-style: italic;">Keine Effekte in der Show</p>';
    return;
  }
  
  // Sort effects by time
  const sortedEffects = [...effects].sort((a, b) => a.time - b.time);
  
  let html = `
    <table class="overview-table">
      <thead>
        <tr>
          <th>Zeit</th>
          <th>Effekt</th>
          <th>Typ</th>
          <th>Dauer</th>
          <th>Box (Empf√§nger)</th>
          <th>Kanal</th>
          <th>Taste</th>
          <th>Preis</th>
          <th>Anzahl</th>
        </tr>
      </thead>
      <tbody>
  `;
  sortedEffects.forEach(effect => {
    html += `
      <tr>
        <td class="time-cell">${effect.timeStr}</td>
        <td><strong>${effect.name}</strong></td>
        <td>${effect.effectType}</td>
        <td>${effect.plannedDuration || '-'}</td>
        <td>${effect.receiver || '-'}</td>
        <td class="channel-cell">${effect.channel || '-'}</td>
        <td class="button-cell">${effect.buttonKey || '-'}</td>
        <td>${effect.price > 0 ? effect.price.toFixed(2) + '‚Ç¨' : '-'}</td>
        <td>${effect.quantity || 1}</td>
      </tr>
    `;
  });
  html += '</tbody></table>';
  overviewDiv.innerHTML = html;
}

function editEffect(id) {
  const effect = effects.find(e => e.id === id);
  if (!effect) return;
  
  // Erstelle Bearbeitungs-Modal
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
    background: rgba(0,0,0,0.8); z-index: 1000; display: flex; 
    align-items: center; justify-content: center;
  `;
  modal.innerHTML = `
    <div style="background: #222; padding: 20px; border-radius: 10px; width: 400px; max-width: 90%;">
      <h3 style="margin-top: 0; color: #fff;">Effekt bearbeiten: ${effect.name}</h3>
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Showzeit (m:s):</label>
      <input id="editTime" value="${effect.timeStr}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Box (Empf√§nger):</label>
      <input id="editReceiver" value="${effect.receiver || ''}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Kanal:</label>
      <input id="editChannel" value="${effect.channel || ''}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Taste:</label>
      <input id="editButtonKey" value="${effect.buttonKey || ''}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <div style="text-align: right; margin-top: 20px;">
        <button onclick="saveEdit(${effect.id})" style="background: #4caf50;">Speichern</button>
        <button onclick="document.body.removeChild(this.parentNode.parentNode.parentNode)" style="background: #d32f2f;">Abbrechen</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // Fokus auf erstes Feld f√ºr schnelle Bearbeitung
  document.getElementById('editTime').focus();
}

function saveEdit(id) {
  const effect = effects.find(e => e.id === id);
  if (!effect) return;
  
  const newTimeStr = document.getElementById('editTime').value;
  const newReceiver = document.getElementById('editReceiver').value; // NEU: Empf√§nger/Boxname
  const newChannel = document.getElementById('editChannel').value;
  const newButtonKey = document.getElementById('editButtonKey').value;
  
  effect.timeStr = newTimeStr;
  effect.time = parseTime(newTimeStr);
  effect.receiver = newReceiver; // NEU: Speichern des Empf√§ngers/Boxnamens
  effect.channel = newChannel;
  effect.buttonKey = newButtonKey;
  
  updateEffectList();
  updateEffectOverview();
  
  // Modal schlie√üen
  const modal = document.querySelector('.modal-content').parentNode;
  document.body.removeChild(modal);
}

function deleteEffect(id) {
  if (confirm('Diesen Effekt wirklich l√∂schen?')) {
    effects = effects.filter(e => e.id !== id);
    updateEffectList();
    updateCostCalculation();
    drawCanvas();
  }
}

function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw marker lines for center
  ctx.strokeStyle = '#333';
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2, 0);
  ctx.lineTo(canvas.width / 2, canvas.height);
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
  
  // Draw effects
  effects.forEach(effect => {
    if (effect.x !== null && effect.y !== null) {
      ctx.beginPath();
      
      let color = '#fff';
      if (effect.effectType === 'rocket') color = '#ff0000';
      if (effect.effectType === 'fountain') color = '#00ff00';
      if (effect.effectType === 'battery') color = '#0000ff';
      
      // Overwrite color for status
      if (effect.status === 'firing') color = '#ff9900'; // Orange
      if (effect.status === 'finished') color = '#336633'; // Dunkelgr√ºn
      
      ctx.fillStyle = color;
      ctx.arc(effect.x, effect.y, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw text label
      ctx.fillStyle = '#eee';
      ctx.font = '10px Arial';
      ctx.fillText(effect.name, effect.x + 10, effect.y + 4);
      ctx.fillText(effect.timeStr, effect.x + 10, effect.y + 16);
    }
  });
}

function saveShow() {
  const showName = document.getElementById('showName').value || 'Unbenannte Show';
  const showData = {
    name: showName,
    effects: effects,
    firingBoxes: firingBoxes, // NEU: Boxen speichern
    timestamp: new Date().toLocaleString()
  };
  
  const savedShows = JSON.parse(localStorage.getItem('savedShows') || '[]');
  const existingIndex = savedShows.findIndex(show => show.name === showName);
  
  if (existingIndex !== -1) {
    savedShows[existingIndex] = showData;
    alert(`Show "${showName}" erfolgreich aktualisiert!`);
  } else {
    savedShows.push(showData);
    alert(`Show "${showName}" erfolgreich gespeichert!`);
  }
  
  localStorage.setItem('savedShows', JSON.stringify(savedShows));
  loadSavedShows();
}

function loadSavedShows() {
  const select = document.getElementById('savedShows');
  select.innerHTML = '<option value="">Gespeicherte Shows</option>';
  const savedShows = JSON.parse(localStorage.getItem('savedShows') || '[]');
  
  savedShows.forEach((show, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = `${show.name} (${show.timestamp})`;
    select.appendChild(option);
  });
}

function selectShow() {
  const select = document.getElementById('savedShows');
  const index = select.value;
  
  if (index !== "") {
    const savedShows = JSON.parse(localStorage.getItem('savedShows'));
    const show = savedShows[index];
    
    document.getElementById('showName').value = show.name;
    // Neue Status-Eigenschaften hinzuf√ºgen falls beim Speichern nicht vorhanden
    effects = show.effects.map(e => ({
        ...e, 
        fired: e.fired || false, // F√ºge 'fired' hinzu, falls es fehlt
        status: e.status || 'planned' // F√ºge 'status' hinzu, falls es fehlt
    }));
    
    // NEU: Boxen aus Show laden
    if (show.firingBoxes) {
        firingBoxes = show.firingBoxes;
        saveFiringBoxes(); // Auch lokal speichern
    } else {
        // Falls alte Show geladen wird, leere Boxenliste, um Inkonsistenzen zu vermeiden
        firingBoxes = []; 
        saveFiringBoxes();
    }
    updateBoxSelect();
    updateBoxList();
    // ENDE NEU
    
    updateEffectList();
    updateCostCalculation();
    drawCanvas();
    alert(`Show "${show.name}" geladen!`);
  }
}

function loadFromSession() {
  const sessionData = localStorage.getItem('fireplannerSession');
  if (sessionData) {
    const data = JSON.parse(sessionData);
    document.getElementById('showName').value = data.name || 'Unbenannte Show';
    // Neue Status-Eigenschaften hinzuf√ºgen falls beim Speichern nicht vorhanden
    effects = data.effects.map(e => ({
        ...e, 
        fired: e.fired || false, 
        status: e.status || 'planned'
    }));
    
    // NEU: Boxen aus Session laden
    if (data.firingBoxes) {
        firingBoxes = data.firingBoxes;
        updateBoxSelect();
        updateBoxList();
    }
    // ENDE NEU
    
    updateEffectList();
    updateCostCalculation();
    drawCanvas();
    alert('üîó Letzte Session geladen!');
  } else {
    alert('‚ùå Keine Session-Daten gefunden.');
  }
}

function autoBackup() {
  const data = {
    name: document.getElementById('showName').value || 'Unbenannte Show',
    effects: effects,
    firingBoxes: firingBoxes, // NEU: Boxen in Backup einschlie√üen
    timestamp: new Date().toLocaleString()
  };
  localStorage.setItem('fireplannerSession', JSON.stringify(data));
  
  const statusDiv = document.getElementById('backupStatus');
  statusDiv.style.display = 'block';
  setTimeout(() => statusDiv.style.display = 'none', 2000);
}

function startAutoBackup() {
  if (autoBackupInterval) {
    clearInterval(autoBackupInterval);
  }
  autoBackupInterval = setInterval(autoBackup, 60000); // Auto-Backup jede Minute
}

function startShow() {
  if (effects.length === 0) {
    alert('Bitte zuerst Effekte zur Show hinzuf√ºgen!');
    return;
  }
  
  // Reset effect statuses
  effects.forEach(e => {
    e.fired = false;
    e.status = 'planned';
  });

  document.getElementById('planScreen').style.display = 'none';
  document.getElementById('showScreen').style.display = 'block';
  showStartTime = Date.now();
  isPaused = false;
  pausedTime = 0;
  
  document.getElementById('musicPlayer').play().catch(e => console.warn('Musik konnte nicht automatisch starten:', e));
  
  // Setze Timer-Update auf 100ms f√ºr pr√§zisere Z√ºndung
  showTimer = setInterval(updateTimer, 100); 
  updateTimer(); // Sofortiger Start
}

function updateTimer() {
  if (isPaused) return;
  
  const elapsedTime = (Date.now() - showStartTime) / 1000;
  document.getElementById('timerDisplay').textContent = formatTime(elapsedTime);
  
  const currentTime = elapsedTime;

  // --- NEUER Z√úND- UND TIMELINE-LOGIK START ---
  effects.forEach(effect => {
    const durationSec = parseTime(effect.plannedDuration);
    
    // 1. Check for ignition time
    if (currentTime >= effect.time && !effect.fired) {
      effect.fired = true;
      effect.status = 'firing';
      
      // Signalton beim Z√ºnden
      playFireBeep();

      // Visuelle Explosion
      if (effect.x !== null && effect.y !== null) {
        triggerExplosion(effect.x, effect.y, effect.effectType);
      }

      // Update Current Effect Display
      document.getElementById('currentEffect').innerHTML = `
        <strong>üî• Z√ºndung!</strong><br>
        ${effect.name} (Box: ${effect.receiver || '-'}, Kanal: ${effect.channel || '-'}, Taste: ${effect.buttonKey || '-'})<br>
        Dauer: ${effect.plannedDuration || 'Unbekannt'}
      `;
    } 
    
    // 2. Check for effect finish time
    if (effect.status === 'firing' && durationSec > 0) {
        if (currentTime >= effect.time + durationSec) {
            effect.status = 'finished';
            // Nur leeren, wenn kein anderer Effekt gerade z√ºndet
            const firingEffects = effects.filter(e => e.status === 'firing');
            if (firingEffects.length === 1 && firingEffects[0].id === effect.id) { // This was the last one
                document.getElementById('currentEffect').innerHTML = '';
            }
        }
    } else if (effect.status === 'firing' && durationSec === 0) {
        // Instant effects clear after a short delay (e.g. 500ms for visual feedback)
         setTimeout(() => {
            if (effect.status === 'firing') {
                 effect.status = 'finished';
                 const firingEffects = effects.filter(e => e.status === 'firing');
                 if (firingEffects.length === 0) {
                    document.getElementById('currentEffect').innerHTML = '';
                 }
            }
        }, 500);
    }
  });

  // Update the timeline display (Anforderung: Z√ºnd-Timeline)
  updateTimelineDisplay(currentTime);

  // --- NEUER Z√úND- UND TIMELINE-LOGIK ENDE ---
  
  // Warning for upcoming effects (e.g., 5 seconds before)
  const nextEffect = effects.find(e => e.time > currentTime && !e.fired);
  if (nextEffect && nextEffect.time - currentTime < 5 && nextEffect.time - currentTime > 0) {
    document.getElementById('warning').textContent = `üö® N√§chster Effekt in: ${(nextEffect.time - currentTime).toFixed(1)}s`;
    document.getElementById('warningFlash').style.opacity = 0.5;
    setTimeout(() => document.getElementById('warningFlash').style.opacity = 0, 100);
    document.getElementById('warningBeep').play().catch(e => console.warn('Warning Beep failed:', e));
  } else {
    document.getElementById('warning').textContent = '';
  }
  
  drawCanvas();
}

function pauseShow() {
  if (!showTimer || isPaused) return;
  isPaused = true;
  pausedTime = Date.now();
  clearInterval(showTimer);
  document.getElementById('musicPlayer').pause();
}

function resumeShow() {
  if (!showTimer || !isPaused) return;
  isPaused = false;
  // Adjust start time based on pause duration
  showStartTime += (Date.now() - pausedTime); 
  showTimer = setInterval(updateTimer, 100);
  document.getElementById('musicPlayer').play().catch(e => console.warn('Musik konnte nicht fortgesetzt werden:', e));
}

function stopShow() {
  if (!showTimer) return;
  clearInterval(showTimer);
  showTimer = null;
  document.getElementById('musicPlayer').pause();
  document.getElementById('musicPlayer').currentTime = 0;
  document.getElementById('timerDisplay').textContent = '00:00';
  document.getElementById('warning').textContent = '';
  document.getElementById('currentEffect').textContent = '';
  document.getElementById('timelineDisplay').innerHTML = '';
  
  // Reset effect statuses for next run
  effects.forEach(e => {
    e.fired = false;
    e.status = 'planned';
  });
  updateEffectList();
  drawCanvas();
  alert('Show gestoppt!');
}

function backToPlan() {
  stopShow();
  document.getElementById('showScreen').style.display = 'none';
  document.getElementById('planScreen').style.display = 'block';
}

function loadMusic() {
  const file = document.getElementById('musicFile').files[0];
  if (file) {
    const player = document.getElementById('musicPlayer');
    player.src = URL.createObjectURL(file);
    player.load();
    alert(`üéµ Musikdatei "${file.name}" geladen!`);
  }
}

function exportShow() {
  const showName = document.getElementById('showName').value || 'fireplanner_show';
  const data = {
    name: showName,
    effects: effects,
    firingBoxes: firingBoxes, // NEU: Boxen exportieren
    timestamp: new Date().toISOString()
  };
  const dataStr = JSON.stringify(data, null, 2);
  const blob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `${showName.replace(/\s/g, '_')}_export.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  alert('Show-Plan erfolgreich als JSON exportiert!');
}

function importShow() {
  const fileInput = document.getElementById('importFile');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Bitte eine JSON-Datei ausw√§hlen!');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const importedData = JSON.parse(e.target.result);
      if (importedData.effects && Array.isArray(importedData.effects)) {
        document.getElementById('showName').value = importedData.name || 'Importierte Show';
        // F√ºge die neuen Status-Eigenschaften hinzu
        effects = importedData.effects.map(e => ({
            ...e, 
            fired: e.fired || false, 
            status: e.status || 'planned'
        }));
        
        // NEU: Boxen importieren
        if (importedData.firingBoxes) {
            firingBoxes = importedData.firingBoxes;
            saveFiringBoxes();
            updateBoxSelect();
            updateBoxList();
        }
        
        updateEffectList();
        updateCostCalculation();
        drawCanvas();
        alert(`‚úÖ Show "${importedData.name || 'Importierte Show'}" erfolgreich importiert!`);
      } else {
        alert('‚ùå Import-Fehler: Die Datei enth√§lt keine g√ºltige Show-Struktur.');
      }
    } catch (error) {
      alert(`‚ùå Import-Fehler: Ung√ºltiges JSON-Format.\n\nFehler: ${error.message}`);
    }
    fileInput.value = '';
  };
  reader.readAsText(file);
}

function printPlan() {
  const printArea = document.getElementById('printArea');
  const planScreen = document.getElementById('planScreen');
  
  // Tempor√§re Kopie der Planungsansicht erstellen
  const tempContent = planScreen.cloneNode(true);
  
  // Entferne nicht ben√∂tigte Elemente f√ºr den Druck
  tempContent.querySelectorAll('.controls, h2:not(:first-of-type), .database-info, .tooltip, input[type="file"], input[placeholder="Name der Show"], button, select, #effectList, #boxControls').forEach(el => el.remove());
  
  // Nur die √úbersicht und Kalkulation behalten
  const finalContent = document.createElement('div');
  finalContent.innerHTML = `
    <h1>${document.getElementById('showName').value || 'FirePlanner Showplan'}</h1>
    <h2>Gesamt√ºbersicht</h2>
  `;
  finalContent.appendChild(document.getElementById('effectOverview').cloneNode(true));
  finalContent.appendChild(document.getElementById('costCalculation').cloneNode(true));
  
  // Canvas als Bild hinzuf√ºgen (optional)
  const canvasImage = new Image();
  canvasImage.src = canvas.toDataURL("image/png");
  canvasImage.style.maxWidth = '100%';
  canvasImage.style.display = 'block';
  canvasImage.style.margin = '20px auto';
  finalContent.innerHTML += '<h2>Platzierungsplan</h2>';
  finalContent.appendChild(canvasImage);
  
  printArea.innerHTML = finalContent.innerHTML;
  
  window.print();
  printArea.innerHTML = ''; // Inhalt wieder leeren
}

// Funktionen f√ºr gespeicherte Effekte (vorherige Nutzung)
function loadSavedEffects() {
    const saved = localStorage.getItem('savedEffects');
    if (saved) {
        savedEffects = JSON.parse(saved);
        updateSavedEffectsList();
    }
}

function updateSavedEffectsList() {
    const select = document.getElementById('effectSavedList');
    select.innerHTML = '<option value="">Vorherige Effekte</option>';
    savedEffects.forEach((effect, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = effect.name;
        select.appendChild(option);
    });
}

function selectSavedEffect() {
    const select = document.getElementById('effectSavedList');
    const index = select.value;
    if (index !== "") {
        const effect = savedEffects[index];
        document.getElementById('name').value = effect.name || '';
        document.getElementById('effectType').value = effect.effectType || 'rocket';
        document.getElementById('plannedDuration').value = effect.plannedDuration || '';
        document.getElementById('price').value = effect.price || '';
        document.getElementById('barcode').value = effect.barcode || '';
        
        // NEU: Box/Kanal aus Vorlage laden
        document.getElementById('boxSelect').value = effect.boxName || '';
        updateChannelSelect(); // Aktualisiert Kan√§le basierend auf Box
        document.getElementById('channelSelect').value = effect.channel || '';
        
        document.getElementById('buttonKey').value = effect.buttonKey || '';
        document.getElementById('quantity').value = effect.quantity || 1;
        document.getElementById('additionalInfo').value = effect.additionalInfo || '';
    }
}


// =================================================================================
// NEUE FUNKTIONEN F√úR BOXEN UND KAN√ÑLE
// =================================================================================

function loadFiringBoxes() {
    const saved = localStorage.getItem('firingBoxes');
    if (saved) {
        try {
            firingBoxes = JSON.parse(saved);
        } catch (e) {
            console.error('Fehler beim Laden der Boxen:', e);
            firingBoxes = [];
        }
    }
    updateBoxList();
    updateBoxSelect();
}

function saveFiringBoxes() {
    localStorage.setItem('firingBoxes', JSON.stringify(firingBoxes));
    updateBoxList();
    updateBoxSelect();
}

function addBox() {
    const nameInput = document.getElementById('boxName');
    const channelsInput = document.getElementById('boxChannels');
    const name = nameInput.value.trim();
    const channels = parseInt(channelsInput.value) || 0;

    if (!name || channels < 1) {
        alert('Bitte Box-Name und eine Kanalanzahl > 0 eingeben!');
        return;
    }

    if (firingBoxes.find(b => b.name === name)) {
        alert(`Box mit dem Namen "${name}" existiert bereits!`);
        return;
    }

    const newBox = {
        name: name,
        channels: channels,
        id: Date.now()
    };

    firingBoxes.push(newBox);
    saveFiringBoxes();
    alert(`Box "${name}" mit ${channels} Kan√§len gespeichert!`);
    nameInput.value = '';
    channelsInput.value = '16';
}

function clearBoxes() {
    if (confirm('Wirklich ALLE Boxen l√∂schen?\nDies kann nicht r√ºckg√§ngig gemacht werden!')) {
        firingBoxes = [];
        saveFiringBoxes();
        alert('Boxen geleert!');
    }
}

function updateBoxList() {
    const listDiv = document.getElementById('boxList');
    if (!listDiv) return;

    if (firingBoxes.length === 0) {
        listDiv.innerHTML = '<em>Keine Boxen gespeichert.</em>';
        return;
    }

    let html = '<strong>Gespeicherte Boxen:</strong><br>';
    firingBoxes.forEach(box => {
        html += `<span>üì¶ ${box.name} (${box.channels} Kan√§le) </span>`;
    });
    listDiv.innerHTML = html;
}

function updateBoxSelect() {
    const select = document.getElementById('boxSelect');
    if (!select) return;

    // Speichere den aktuell ausgew√§hlten Wert
    const selectedValue = select.value;

    select.innerHTML = '<option value="">Box w√§hlen (Empf√§nger)</option>';
    firingBoxes.forEach(box => {
        const option = document.createElement('option');
        option.value = box.name;
        option.textContent = `${box.name} (${box.channels} Kan√§le)`;
        select.appendChild(option);
    });
    
    // Setze den vorherigen Wert wieder, falls vorhanden
    if (selectedValue && firingBoxes.find(b => b.name === selectedValue)) {
        select.value = selectedValue;
    }
    
    // Unabh√§ngig davon, rufe updateChannelSelect auf, um die Kan√§le anzupassen
    updateChannelSelect();
}

function updateChannelSelect() {
    const boxSelect = document.getElementById('boxSelect');
    const channelSelect = document.getElementById('channelSelect');
    if (!boxSelect || !channelSelect) return;

    const selectedBoxName = boxSelect.value;
    const selectedChannelValue = channelSelect.value;
    
    channelSelect.innerHTML = '<option value="">Kanal w√§hlen</option>';

    if (!selectedBoxName) {
        channelSelect.disabled = true;
        return;
    }

    const box = firingBoxes.find(b => b.name === selectedBoxName);
    
    if (box && box.channels > 0) {
        channelSelect.disabled = false;
        for (let i = 1; i <= box.channels; i++) {
            const option = document.createElement('option');
            option.value = i.toString();
            option.textContent = `Kanal ${i}`;
            channelSelect.appendChild(option);
        }
        
        // Setze den vorherigen Kanal wieder, falls er g√ºltig ist
        if (selectedChannelValue && parseInt(selectedChannelValue) <= box.channels) {
            channelSelect.value = selectedChannelValue;
        }
    } else {
        channelSelect.disabled = true;
    }
}
// =================================================================================
// ENDE NEUE FUNKTIONEN F√úR BOXEN UND KAN√ÑLE
// =================================================================================


// =================================================================================
// QR-Code / Remote Funktionen
// =================================================================================

function generateQRCode() {
    alert('Funktion zur Generierung des QR-Codes erfordert eine externe Bibliothek und einen Remote-Server, die hier nicht verf√ºgbar sind. Bitte nutzen Sie die Export/Import-Funktion.');
    // Die QR-Code-Funktionalit√§t wird hier deaktiviert, da sie nicht mit reinem HTML/JS realisierbar ist.
}

function closeQRModal() {
    document.getElementById('qrModal').style.display = 'none';
}

// =================================================================================
// GitHub Backup Funktionen (Beibehalten, aber nicht implementiert)
// =================================================================================

let githubConfig = {}; // Placeholder

function ensureGithubConfigInteractive() {
    alert('Die GitHub-Funktionalit√§t ist in dieser lokalen Version nicht vollst√§ndig implementiert und erfordert API-Schl√ºssel. Bitte nutzen Sie die lokalen JSON Export/Import Funktionen.');
    return false;
}

async function githubBackup() {
    // Funktion beibehalten, aber deaktiviert
    alert('GitHub-Backup ist in dieser lokalen Version deaktiviert. Nutzen Sie den lokalen JSON-Export.');
}

async function githubRestore() {
    // Funktion beibehalten, aber deaktiviert
    alert('GitHub-Restore ist in dieser lokalen Version deaktiviert. Nutzen Sie den lokalen JSON-Import.');
}

// =================================================================================
// Such-Funktionen (Beibehalten)
// =================================================================================

function showSearch() {
    document.getElementById('effectDatabase').style.display = 'none';
    document.getElementById('effectSearch').style.display = 'inline-block';
    document.getElementById('effectSearch').focus();
    document.getElementById('searchButton').style.display = 'none';
}

function hideSearch() {
    setTimeout(() => {
        document.getElementById('effectSearch').style.display = 'none';
        document.getElementById('effectDatabase').style.display = 'inline-block';
        if (effectDatabase.length > 100) {
            document.getElementById('searchButton').style.display = 'inline-block';
        }
        updateDatabaseList(); // Stellt die Standard-Liste wieder her
    }, 200);
}

function searchEffects() {
    const query = document.getElementById('effectSearch').value.toLowerCase();
    const select = document.getElementById('effectDatabase');
    select.innerHTML = '';

    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = `üîç Suchergebnisse:`;
    select.appendChild(defaultOption);

    const filteredEffects = effectDatabase.filter(effect => 
        effect.name.toLowerCase().includes(query) || 
        (effect.barcode && effect.barcode.includes(query))
    );

    filteredEffects.slice(0, 50).forEach((effect, index) => { // Max 50 Ergebnisse anzeigen
        const option = document.createElement('option');
        // Finde den Index des Effekts im Original-Array, um ihn auszuw√§hlen
        const originalIndex = effectDatabase.findIndex(e => e.name === effect.name && e.barcode === effect.barcode);
        option.value = originalIndex.toString(); 
        
        const price = (effect.price && effect.price > 0) ? `${effect.price}‚Ç¨` : '';
        const duration = effect.duration || effect.plannedDuration || '';
        const type = effect.effectType || effect.type || '';
        const hasImage = effect.image ? 'üì∏ ' : '';
        
        option.textContent = `${hasImage}${effect.name} ${price ? '- ' + price : ''} ${duration ? '- ' + duration : ''} ${type ? '- ' + type : ''}`;
        select.appendChild(option);
    });
    
    if (filteredEffects.length > 50) {
        const moreOption = document.createElement('option');
        moreOption.value = 'more';
        moreOption.textContent = `... ${filteredEffects.length - 50} weitere Ergebnisse gefunden. Pr√§zisieren Sie die Suche.`;
        moreOption.disabled = true;
        select.appendChild(moreOption);
    } else if (filteredEffects.length === 0 && query.length > 0) {
        const noResults = document.createElement('option');
        noResults.value = 'none';
        noResults.textContent = `‚ùå Keine Ergebnisse f√ºr "${query}"`;
        noResults.disabled = true;
        select.appendChild(noResults);
    }
}


</script>
</body>
</html>
