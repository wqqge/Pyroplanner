<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>🎆 FirePlanner 2D - Pro Advanced (Korrigiert)</title>
<style>
/* (Styles unverändert, exakt wie im Original) */
body {
  box-sizing: border-box;
  font-family: Arial, sans-serif;
  margin: 0;
  background: #111;
  color: #eee;
}
h1, h2 {
  text-align: center;
  margin: 10px 0;
}
input, button, select, textarea {
  margin: 5px;
  padding: 8px;
  background: #222;
  color: #fff;
  border: 1px solid #555;
  border-radius: 5px;
  font-size: 14px;
  outline: none;
}
input:focus, textarea:focus, select:focus {
  background: #333;
  border-color: #4caf50;
  box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
}
input[type="text"], input[type="number"], textarea {
  width: 200px;
  max-width: 100%;
}
button {
  cursor: pointer;
  background: #444;
  transition: 0.2s;
  padding: 10px 15px;
}
button:hover {
  background: #666;
}
#container {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 20px;
}
#effectList {
  max-width: 400px;
  margin: 10px;
}
.effect-item {
  border: 1px solid #555;
  padding: 10px;
  margin: 8px 0;
  border-radius: 5px;
  background: #222;
  cursor: move;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.2s;
}
.effect-item:hover {
  background: #333;
  transform: translateY(-2px);
}
.effect-item.dragging {
  opacity: 0.5;
  transform: rotate(5deg);
}
.effect-item.low-stock {
  border-color: #ff9800;
  background: #2d1b0f;
}
.effect-item.out-of-stock {
  border-color: #f44336;
  background: #2d0f0f;
}
#canvasContainer {
  position: relative;
  margin: 10px auto;
  border: 2px solid #555;
  background: #000;
  border-radius: 8px;
}
#fireworkCanvas {
  cursor: crosshair;
  display: block;
  border-radius: 6px;
}
.tooltip {
  position: relative;
  display: inline-block;
}
.tooltip .tooltiptext {
  visibility: hidden;
  width: 200px;
  background: #333;
  color: #fff;
  text-align: left;
  border-radius: 5px;
  padding: 8px;
  position: absolute;
  z-index: 1;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
#timerDisplay {
  font-size: 3em;
  text-align: center;
  margin: 20px 0;
  font-weight: bold;
  color: #0ff;
}
#currentEffect {
  font-size: 1.4em;
  color: #ff0;
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #222;
  border-radius: 5px;
  min-height: 60px;
}
#warning {
  font-size: 2.5em;
  color: #f00;
  text-align: center;
  margin: 15px 0;
  font-weight: bold;
}
#timelineDisplay {
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #222;
  border-radius: 5px;
}
#printArea {
  display: none;
}
#warningFlash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: red;
  opacity: 0;
  pointer-events: none;
  border-radius: 5px;
  transition: opacity 0.1s;
}
.controls {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #222;
  border-radius: 8px;
}
.effect-delete {
  background: #d32f2f;
  color: white;
  border: none;
  padding: 5px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
}
.effect-delete:hover {
  background: #b71c1c;
}
#costCalculation {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #1a4d1a;
  border-radius: 8px;
  border: 2px solid #2e7d32;
}
#costCalculation h3 {
  margin: 0 0 10px 0;
  color: #4caf50;
}
#totalCost {
  font-size: 1.5em;
  font-weight: bold;
  color: #81c784;
}
#effectCount {
  color: #a5d6a7;
  margin-top: 5px;
}
.explosion {
  position: absolute;
  pointer-events: none;
  border-radius: 50%;
  animation: explode 1s ease-out forwards;
}
@keyframes explode {
  0% { transform: scale(0); opacity: 1; }
  50% { transform: scale(1.5); opacity: 0.8; }
  100% { transform: scale(3); opacity: 0; }
}
#qrModal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.8);
}
.modal-content {
  background-color: #222;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #555;
  border-radius: 10px;
  width: 300px;
  text-align: center;
}
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}
.close:hover {
  color: #fff;
}
#backupStatus {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #4caf50;
  color: white;
  padding: 10px;
  border-radius: 5px;
  display: none;
  z-index: 1000;
}
#effectOverview {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #1a1a2e;
  border-radius: 8px;
  border: 2px solid #16213e;
}
#effectOverview h3 {
  margin: 0 0 15px 0;
  color: #0f3460;
}
#overviewTable {
  overflow-x: auto;
}
.overview-table {
  width: 100%;
  border-collapse: collapse;
  background: #222;
  border-radius: 5px;
  overflow: hidden;
}
.overview-table th {
  background: #333;
  color: #fff;
  padding: 10px 8px;
  text-align: left;
  font-size: 12px;
  border-bottom: 2px solid #555;
}
.overview-table td {
  padding: 8px;
  border-bottom: 1px solid #444;
  font-size: 11px;
  color: #ddd;
}
.overview-table tr:hover {
  background: #2a2a2a;
}
.time-cell {
  color: #4caf50;
  font-weight: bold;
}
.channel-cell {
  color: #2196f3;
  font-weight: bold;
}
.button-cell {
  color: #ff9800;
  font-weight: bold;
}
.database-info {
  background: #2a2a2a;
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
  font-size: 12px;
  color: #ccc;
}
.image-preview {
  max-width: 200px;
  max-height: 150px;
  border-radius: 5px;
  border: 2px solid #555;
  margin: 10px 0;
}
.video-preview {
  max-width: 200px;
  max-height: 150px;
  border-radius: 5px;
  border: 2px solid #555;
  margin: 10px 0;
}
.effect-image {
  max-width: 50px;
  max-height: 50px;
  border-radius: 3px;
  margin-right: 10px;
  vertical-align: middle;
}
.effect-video {
  max-width: 50px;
  max-height: 50px;
  border-radius: 3px;
  margin-right: 10px;
  vertical-align: middle;
}
.database-item {
  display: flex;
  align-items: center;
  padding: 5px;
  margin: 2px 0;
  background: #333;
  border-radius: 3px;
}
.database-item img {
  margin-right: 10px;
}
#inventoryWarning {
  display: none;
  background: #d32f2f;
  color: white;
  padding: 15px;
  margin: 20px 0;
  border-radius: 8px;
  text-align: center;
}
#inventoryWarning h3 {
  margin: 0 0 10px 0;
}
#beatInfo {
  margin: 10px 0;
  padding: 10px;
  background: #1a1a2e;
  border-radius: 5px;
  display: none;
}
#collaborationStatus {
  position: fixed;
  top: 60px;
  right: 20px;
  background: #2196f3;
  color: white;
  padding: 10px;
  border-radius: 5px;
  display: none;
  z-index: 1000;
}
.beat-marker {
  position: absolute;
  width: 2px;
  height: 100%;
  background: #ff9800;
  opacity: 0.7;
  pointer-events: none;
}
.collaboration-cursor {
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  pointer-events: none;
  z-index: 100;
  transition: all 0.1s;
}

/* Verstecke alle interaktiven Elemente beim Drucken */
@media print {
  button, select, input, textarea, .effect-delete, .effect-edit { display: none !important; }
  #effectList h3, #effectList .effect-item button { display: none !important; }
  .controls, #container > #effectList { display: none !important; }
  #planScreen > h2:not(.print-keep), #planScreen > div:not(#printArea):not(#effectOverview):not(#costCalculation):not(.print-keep) { display: none !important; }
  #planScreen > input, #planScreen > select, #planScreen > button { display: none !important; }
  #planScreen > br { display: none !important; }
  .database-info { display: none !important; }

  /* Verstecke spezifische Bearbeitungsbereiche */
  #planScreen > div[style*="display: grid"], 
  #planScreen > div[style*="display: flex"],
  #planScreen > div[style*="margin: 10px 0"]:not(#effectOverview):not(#costCalculation):not(#inventoryWarning) { display: none !important; }

  /* Verstecke alle Formularbereiche */
  #planScreen > div:has(input), 
  #planScreen > div:has(select), 
  #planScreen > div:has(button),
  #planScreen > div:has(textarea) { display: none !important; }

  /* Verstecke Dropdown-Menüs und Eingabefelder */
  .effect-item select, .effect-item input, .effect-item button { display: none !important; }

  /* Verstecke Bearbeitungshinweise */
  .database-info, .beat-info, #beatInfo { display: none !important; }

  /* Verstecke Kollaborations-Status */
  #collaborationStatus, #backupStatus { display: none !important; }

  /* Zeige nur relevante Bereiche */
  #printArea { display: block !important; }
  #effectOverview { display: block !important; }
  #costCalculation { display: block !important; }

  /* Verbessere Tabellen-Layout */
  .overview-table th { background-color: #f0f0f0 !important; color: #000 !important; }
  .overview-table td { color: #000 !important; }

  /* Seitenumbrüche optimieren */
  .summary { page-break-inside: avoid; }
  .inventory-warning { page-break-inside: avoid; }
  table { page-break-inside: auto; }
  tr { page-break-inside: avoid; page-break-after: auto; }

  /* Verstecke Scrollbalken */
  * { overflow: visible !important; }
}
</style>
</head>
<body>

<h1>🎆 FirePlanner 2D - Pro Advanced (Korrigiert)</h1>

<div id="planScreen">
<h2>Show-Name</h2>
<input id="showName" placeholder="Name der Show">

<h2>Effekt hinzufügen</h2>
<select id="effectSavedList" onchange="selectSavedEffect()">
  <option value="">Vorherige Effekte</option>
</select>
<div style="position: relative; display: inline-block;">
  <select id="effectDatabase" onchange="selectFromDatabase()">
    <option value="">Effekt-Datenbank</option>
  </select>
  <input type="text" id="effectSearch" placeholder="🔍 Effekt suchen..." 
         style="display: none; position: absolute; top: 0; left: 0; width: 100%; z-index: 10;"
         onkeyup="searchEffects()" onblur="hideSearch()">
</div>
<button onclick="showSearch()" id="searchButton" style="display: none;">🔍 Suchen</button><br>

<div class="database-info">
  📊 <strong>Excel-Import Format:</strong> Name | Barcode | Dauer | Preis | Typ | Lagerbestand<br>
  Beispiel: "Goldener Regen | 4260123456789 | 0:15 | 12.50 | rocket | 25"<br>
  📸 <strong>Bilder & Videos:</strong> Optional - können einzeln hochgeladen werden
</div>

<h3>📸 Bild für Effekt (Optional)</h3>
<input type="file" id="effectImage" accept="image/*" onchange="previewImage()">
<div id="imagePreview" style="margin: 10px 0;"></div>
<button onclick="clearImage()">🗑️ Bild entfernen</button>

<h3>🎬 Video-Vorschau (Optional)</h3>
<input type="file" id="effectVideo" accept="video/*" onchange="previewVideo()">
<div id="videoPreview" style="margin: 10px 0;"></div>
<button onclick="clearVideo()">🗑️ Video entfernen</button>

<input id="name" placeholder="Effektname">
<select id="effectType">
  <option value="rocket">Rakete</option>
  <option value="fountain">Fontäne</option>
  <option value="battery">Batterie</option>
</select>
<input id="plannedDuration" placeholder="Dauer (m:s)">
<input id="price" placeholder="Preis (€)" type="number" step="0.01">
<input id="barcode" placeholder="Barcode/EAN">
<input id="time" placeholder="Showzeit (m:s)">
<input id="channel" placeholder="Kanal" type="number" min="1">
<input id="receiver" placeholder="Empfänger">
<input id="buttonKey" placeholder="Taste">
<input id="quantity" placeholder="Anzahl Effekte">
<input id="stockQuantity" placeholder="Lagerbestand" type="number">
<textarea id="additionalInfo" placeholder="Zusatzinfos"></textarea>
<button onclick="addEffect()">Effekt speichern</button>
<button onclick="addToDatabase()">Zur Datenbank hinzufügen</button>
<input type="file" id="excelImport" accept=".csv,.txt,.tsv" onchange="importExcelDatabase()">
<button onclick="document.getElementById('excelImport').click()">📊 Excel-Datenbank importieren</button>
<button onclick="clearDatabase()">🗑️ Datenbank leeren</button>

<div id="container">
  <div id="canvasContainer">
    <canvas id="fireworkCanvas" width="800" height="500"></canvas>
    <div id="warningFlash"></div>
  </div>
  <div id="effectList"></div>
</div>

<div id="costCalculation">
  <h3>💰 Kostenkalkulation</h3>
  <div id="totalCost">Gesamtkosten: 0,00 €</div>
  <div id="effectCount">Anzahl Effekte: 0</div>
</div>

<div id="inventoryWarning">
  <h3>⚠️ Lagerbestand-Warnung</h3>
  <div id="lowStockItems"></div>
</div>

<div id="effectOverview">
  <h3>📋 Effekt-Übersicht</h3>
  <div id="overviewTable"></div>
</div>

<h2>🎵 Musik & Beat-Sync</h2>
<input type="file" id="musicFile" accept="audio/*" onchange="loadMusic()">
<button onclick="analyzeBeat()" id="beatAnalyzeBtn" style="display: none;">🎵 Beat analysieren</button>
<button onclick="autoSyncEffects()" id="autoSyncBtn" style="display: none;">⚡ Auto-Sync zu Beats</button>
<div id="beatInfo">
  <strong>🎵 Beat-Analyse:</strong><br>
  <span id="bpmDisplay">BPM: Nicht analysiert</span><br>
  <span id="beatCount">Beats gefunden: 0</span>
</div>

<h2>📡 Zündanlagen-Verwaltung</h2>
<div style="background: #1a1a2e; padding: 20px; border-radius: 8px; border: 2px solid #16213e; margin: 20px 0;">
  <h3 style="color: #4caf50; margin: 0 0 15px 0;">🎯 Effekt zu Zündbox zuweisen</h3>
  
  <div id="currentSelection" style="background: #222; padding: 15px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #4caf50;">
    <p style="color: #666; font-style: italic;">Kein Effekt ausgewählt</p>
  </div>
  
  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
    <div>
      <label style="color: #ccc; display: block; margin: 0 0 5px;">📡 Zündbox auswählen:</label>
      <select id="ignitionBox" onchange="selectIgnitionBox()" style="width: 100%; padding: 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
        <option value="">Box wählen</option>
        <option value="A">Box A (32 Kanäle)</option>
        <option value="B">Box B (32 Kanäle)</option>
        <option value="C">Box C (32 Kanäle)</option>
        <option value="D">Box D (32 Kanäle)</option>
        <option value="E">Box E (32 Kanäle)</option>
        <option value="F">Box F (32 Kanäle)</option>
      </select>
    </div>
    
    <div>
      <label style="color: #ccc; display: block; margin: 0 0 5px;">🔢 Kanal (1-32):</label>
      <input id="selectedChannel" type="number" min="1" max="32" placeholder="Kanal eingeben" style="width: 100%; padding: 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
    </div>
  </div>
  
  <div style="text-align: center; margin: 20px 0;">
    <button onclick="assignToBox()" style="background: #4caf50; color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
      🎆 Effekt zu Box zuweisen
    </button>
  </div>
  
  <div style="margin: 20px 0;">
    <h4 style="color: #ff9800; margin: 0 0 10px 0;">⚡ Schnell-Zuweisung:</h4>
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px;">
      <button onclick="quickAssign('A', 1)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">A1</button>
      <button onclick="quickAssign('A', 2)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">A2</button>
      <button onclick="quickAssign('B', 1)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">B1</button>
      <button onclick="quickAssign('B', 2)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">B2</button>
      <button onclick="quickAssign('C', 1)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">C1</button>
      <button onclick="quickAssign('C', 2)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">C2</button>
    </div>
  </div>
  
  <div style="text-align: center; margin: 20px 0;">
    <button onclick="showIgnitionOverview()" style="background: #ff9800; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin: 5px;">
      📋 Zündanlagen-Übersicht anzeigen
    </button>
    <button onclick="resetBoxPositions()" style="background: #9c27b0; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin: 5px;">
      🔄 Box-Positionen zurücksetzen
    </button>
  </div>
</div>

<div id="ignitionOverview" style="background: #1a2e1a; padding: 20px; border-radius: 8px; border: 2px solid #2e7d32; margin: 20px 0; display: none;">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
    <h3 style="color: #4caf50; margin: 0;">📡 Zündanlagen-Übersicht</h3>
    <button onclick="hideIgnitionOverview()" style="background: #666; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">✕ Schließen</button>
  </div>
  <div id="ignitionBoxes"></div>
</div>

<h2>🌡️ Wetter-Monitor</h2>
<div style="display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0;">
  <input id="windSpeed" placeholder="Windgeschwindigkeit (km/h)" type="number">
  <select id="windDirection">
    <option value="">Windrichtung</option>
    <option value="N">Nord</option>
    <option value="NO">Nordost</option>
    <option value="O">Ost</option>
    <option value="SO">Südost</option>
    <option value="S">Süd</option>
    <option value="SW">Südwest</option>
    <option value="W">West</option>
    <option value="NW">Nordwest</option>
  </select>
  <input id="temperature" placeholder="Temperatur (°C)" type="number">
  <input id="humidity" placeholder="Luftfeuchtigkeit (%)" type="number">
  <button onclick="checkWeatherConditions()">🌤️ Wetter prüfen</button>
</div>
<div id="weatherStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>

<div class="controls">
<button onclick="saveShow()">Show speichern</button>
<button onclick="loadSavedShows()">Show laden</button>
<select id="savedShows" onchange="selectShow()">
  <option value="">Gespeicherte Shows</option>
</select>
<button onclick="exportShow()">Export JSON</button>
<input type="file" id="importFile" accept=".json" onchange="importShow()">
<button onclick="importShow()">Import JSON</button>
<button onclick="printPlan()">Druckversion</button>
<button onclick="generateQRCode()">📱 Smartphone-Steuerung</button>
<button onclick="loadFromSession()">🔗 Session laden</button>
<button onclick="startCollaboration()">👥 Team-Kollaboration</button>
<button onclick="joinCollaboration()">🤝 Team beitreten</button>
<button onclick="autoBackup()">💾 Auto-Backup</button>
<button onclick="startShow()">Show starten</button>
<button onclick="pauseShow()">Pause</button>
<button onclick="resumeShow()">Fortsetzen</button>
<button onclick="stopShow()">Stopp</button>
</div>
</div>

<div id="showScreen" style="display:none;">
<h2>Show Timer</h2>
<div id="timerDisplay">00:00</div>
<div id="warning"></div>
<div id="currentEffect"></div>
<div id="timelineDisplay"></div>
<button onclick="backToPlan()" style="margin: 20px;">Zurück zur Planung</button>
</div>

<div class="print-area" id="printArea"></div>

<!-- QR Code Modal -->
<div id="qrModal">
  <div class="modal-content">
    <span class="close" onclick="closeQRModal()">&times;</span>
    <h3>📱 Smartphone-Steuerung</h3>
    <div id="qrCode"></div>
    <p>Scanne den QR-Code mit deinem Smartphone</p>
    <div id="remoteUrl"></div>
  </div>
</div>

<div id="backupStatus">Backup erstellt!</div>
<div id="collaborationStatus">Team-Modus aktiv</div>

<audio id="warningBeep" preload="auto">
  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
</audio>
<audio id="fireBeep" preload="auto">
  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
</audio>
<audio id="musicPlayer"></audio>

<script>
// ===== KORRIGIERTE UND VOLLSTÄNDIGE VERSION =====

// Daten & Status
let effects = [];
let showTimer = null;
let showStartTime = 0;
let isPaused = false;
let pausedTime = 0;
let canvas, ctx;
let savedEffects = [];
let effectDatabase = [];
let draggedEffect = null;
let autoBackupInterval = null;
let currentEffectImage = null;
let currentEffectVideo = null;

// Zündanlagen
let selectedEffect = null;
let ignitionBoxes = { A: {}, B: {}, C: {}, D: {}, E: {}, F: {} };

// Zündbox-Positionen
let ignitionBoxPositions = {
  A: { x: 50, y: 50 },
  B: { x: 150, y: 50 },
  C: { x: 250, y: 50 },
  D: { x: 50, y: 120 },
  E: { x: 150, y: 120 },
  F: { x: 250, y: 120 }
};

// Drag & Drop für Zündboxen
let draggedBox = null;
let dragOffset = { x: 0, y: 0 };
let isDraggingBox = false;

// Beat-Sync
let audioContext = null;
let audioBuffer = null;
let beatTimes = [];
let bpm = 0;

// Collaboration
let collaborationId = null;
let isCollaborating = false;
let collaborators = [];
let lastSyncTime = 0;

// Inventory
let inventoryWarnings = [];

// Cleanup
let intervals = [];
let eventListeners = [];

// ===== Utility =====
function escapeHtml(text) {
  if (!text) return '';
  const div = document.createElement('div');
  div.textContent = text.toString();
  return div.innerHTML;
}
function generateUniqueId() {
  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${Math.floor(Math.random() * 10000)}`;
}
function safeParseInt(value, defaultValue = 0) {
  const parsed = parseInt(value);
  return isNaN(parsed) ? defaultValue : parsed;
}
function safeParseFloat(value, defaultValue = 0) {
  const parsed = parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}
function addManagedInterval(callback, delay) {
  const id = setInterval(callback, delay);
  intervals.push(id);
  return id;
}
function addManagedEventListener(element, event, callback) {
  if (!element) return;
  element.addEventListener(event, callback);
  eventListeners.push({ element, event, callback });
}
function cleanup() {
  intervals.forEach(id => { try { clearInterval(id); } catch (e) { console.warn('Error clearing interval:', e); } });
  intervals = [];
  eventListeners.forEach(({ element, event, callback }) => {
    try { if (element && element.removeEventListener) element.removeEventListener(event, callback); } catch (e) { console.warn('Error removing event listener:', e); }
  });
  eventListeners = [];
}
function showSuccessMessage(message, duration = 3000) {
  const successMsg = document.createElement('div');
  successMsg.style.cssText = `
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: linear-gradient(45deg, #4caf50, #66bb6a);
    color: white; padding: 15px 25px; border-radius: 8px;
    z-index: 10000; font-weight: bold; font-size: 16px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    border: 2px solid #2e7d32;
  `;
  successMsg.textContent = message;
  document.body.appendChild(successMsg);
  successMsg.style.opacity = '0';
  successMsg.style.transform = 'translateX(-50%) translateY(-20px)';
  setTimeout(() => {
    successMsg.style.transition = 'all 0.3s ease';
    successMsg.style.opacity = '1';
    successMsg.style.transform = 'translateX(-50%) translateY(0)';
  }, 10);
  setTimeout(() => {
    successMsg.style.opacity = '0';
    successMsg.style.transform = 'translateX(-50%) translateY(-20px)';
    setTimeout(() => { if (successMsg.parentNode) successMsg.parentNode.removeChild(successMsg); }, 300);
  }, duration);
}

// ===== Persistence helpers =====
function saveEffectsToStorage() {
  try { localStorage.setItem('effects', JSON.stringify(effects)); } catch (e) { console.warn('saveEffects failed', e); }
}
function loadEffectsFromStorage() {
  try {
    const s = localStorage.getItem('effects');
    if (s) {
      const p = JSON.parse(s);
      if (Array.isArray(p)) effects = p;
    }
  } catch (e) { console.warn('loadEffects failed', e); }
}
function saveDB() {
  try { localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase)); } catch (e) { console.warn('saveDB failed', e); }
}
function loadDB() {
  try {
    const s = localStorage.getItem('effectDatabase');
    if (s) {
      const p = JSON.parse(s);
      if (Array.isArray(p)) effectDatabase = p;
    }
  } catch (e) { console.warn('loadDB failed', e); }
}

// ===== Initialization =====
window.onload = function() {
  try {
    canvas = document.getElementById('fireworkCanvas');
    if (!canvas) { alert('❌ FEHLER: Canvas-Element nicht gefunden! Seite neu laden (F5)'); return; }
    ctx = canvas.getContext('2d');
    if (!ctx) { alert('❌ FEHLER: Canvas wird nicht unterstützt!'); return; }

    loadSavedShows();
    loadSavedEffects();
    loadDB();                 // load database first
    loadEffectsFromStorage(); // load persisted effects
    loadIgnitionBoxPositions();
    updateEffectList();
    updateCostCalculation();
    drawCanvas();
    startAutoBackup();
    initializeAudioContext();
    setupEventListeners();
  } catch (error) {
    alert('❌ KRITISCHER FEHLER beim Laden der Anwendung!\n\nBitte Seite neu laden (F5)');
  }
};

// ===== Event listeners & canvas handlers =====
function setupEventListeners() {
  if (!canvas) return;

  const canvasClickHandler = function(e) {
    try {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (isCollaborating) broadcastCursorPosition(x, y);

      let clickedBox = null;
      Object.keys(ignitionBoxPositions).forEach(boxName => {
        const pos = ignitionBoxPositions[boxName];
        if (x >= pos.x - 25 && x <= pos.x + 25 && y >= pos.y - 15 && y <= pos.y + 15) clickedBox = boxName;
      });
      if (clickedBox) { showIgnitionBoxDetails(clickedBox); return; }

      const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);
      if (unplacedEffects.length > 0) {
        const effectToPlace = unplacedEffects[0];
        effectToPlace.x = x; effectToPlace.y = y;
        updateInventoryForEffect(effectToPlace);
        updateEffectList(); drawCanvas();
        if (isCollaborating) syncWithCollaborators();
        showSuccessMessage(`✅ "${escapeHtml(effectToPlace.name)}" platziert!`);
        saveEffectsToStorage();
      }
    } catch (error) { console.error('Fehler beim Canvas-Click:', error); }
  };
  addManagedEventListener(canvas, 'click', canvasClickHandler);

  const mouseMoveHandler = function(e) {
    if (isCollaborating) {
      try {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        broadcastCursorPosition(x, y);
      } catch (error) { console.warn('Fehler bei Cursor-Broadcast:', error); }
    }
  };
  addManagedEventListener(canvas, 'mousemove', mouseMoveHandler);

  const mouseDownHandler = function(e) {
    try {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      Object.keys(ignitionBoxPositions).forEach(boxName => {
        const pos = ignitionBoxPositions[boxName];
        if (x >= pos.x - 25 && x <= pos.x + 25 && y >= pos.y - 15 && y <= pos.y + 15) {
          draggedBox = boxName; isDraggingBox = true; dragOffset.x = x - pos.x; dragOffset.y = y - pos.y; canvas.style.cursor = 'grabbing'; e.preventDefault();
        }
      });
    } catch (error) { console.error('Fehler bei Mouse-Down:', error); }
  };
  addManagedEventListener(canvas, 'mousedown', mouseDownHandler);

  const mouseMoveBoxHandler = function(e) {
    try {
      if (isDraggingBox && draggedBox) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        ignitionBoxPositions[draggedBox].x = Math.max(25, Math.min(canvas.width - 25, x - dragOffset.x));
        ignitionBoxPositions[draggedBox].y = Math.max(15, Math.min(canvas.height - 15, y - dragOffset.y));
        drawCanvas(); e.preventDefault();
      } else {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        let hoveringBox = false;
        Object.keys(ignitionBoxPositions).forEach(boxName => {
          const pos = ignitionBoxPositions[boxName];
          if (x >= pos.x - 25 && x <= pos.x + 25 && y >= pos.y - 15 && y <= pos.y + 15) hoveringBox = true;
        });
        canvas.style.cursor = hoveringBox ? 'grab' : 'crosshair';
      }
      if (isCollaborating) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        broadcastCursorPosition(x, y);
      }
    } catch (error) { console.warn('Fehler bei Box-Bewegung:', error); }
  };
  addManagedEventListener(canvas, 'mousemove', mouseMoveBoxHandler);

  const mouseUpHandler = function(e) {
    try {
      if (isDraggingBox && draggedBox) {
        try { localStorage.setItem('ignitionBoxPositions', JSON.stringify(ignitionBoxPositions)); } catch (saveError) { console.warn('Konnte Box-Positionen nicht speichern:', saveError); }
        if (isCollaborating) syncWithCollaborators();
        showSuccessMessage(`✅ Box ${draggedBox} verschoben!`);
      }
      isDraggingBox = false; draggedBox = null; canvas.style.cursor = 'crosshair';
    } catch (error) { console.error('Fehler bei Mouse-Up:', error); }
  };
  addManagedEventListener(canvas, 'mouseup', mouseUpHandler);

  const dragOverHandler = function(e) { e.preventDefault(); };
  const dropHandler = function(e) {
    e.preventDefault();
    if (draggedEffect) {
      try {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        draggedEffect.x = x; draggedEffect.y = y;
        updateEffectList(); drawCanvas();
        if (isCollaborating) syncWithCollaborators();
        draggedEffect = null;
        saveEffectsToStorage();
      } catch (error) { console.error('Fehler beim Drop:', error); }
    }
  };
  addManagedEventListener(canvas, 'dragover', dragOverHandler);
  addManagedEventListener(canvas, 'drop', dropHandler);
}

// ===== Time functions =====
function parseTime(timeStr) {
  if (!timeStr) return 0;
  try {
    const parts = timeStr.toString().split(':');
    if (parts.length === 2) return safeParseInt(parts[0]) * 60 + safeParseInt(parts[1]);
    return safeParseInt(timeStr);
  } catch (error) { console.warn('Fehler beim Parsen der Zeit:', timeStr, error); return 0; }
}
function formatTime(seconds) {
  try {
    const safeSeconds = safeParseInt(seconds);
    const mins = Math.floor(safeSeconds / 60);
    const secs = safeSeconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  } catch (error) { console.warn('Fehler beim Formatieren der Zeit:', seconds, error); return '00:00'; }
}

// ===== Add effect (robust, persists) =====
function addEffect() {
  console.log('SICHERE addEffect() gestartet');
  let backup = null;
  try {
    const nameField = document.getElementById('name');
    const timeField = document.getElementById('time');
    if (!nameField || !timeField) { alert('KRITISCHER FEHLER: Eingabefelder nicht gefunden!'); return false; }

    const name = (nameField.value || '').trim();
    const time = (timeField.value || '').trim();
    if (!name) { alert('Bitte einen Effektnamen eingeben!'); nameField.focus(); return false; }
    if (!time) { alert('Bitte eine Showzeit eingeben (z.B. 1:30)!'); timeField.focus(); return false; }

    const effectType = document.getElementById('effectType')?.value || 'rocket';
    const plannedDuration = document.getElementById('plannedDuration')?.value?.trim() || '';
    const price = safeParseFloat(document.getElementById('price')?.value);
    const barcode = document.getElementById('barcode')?.value?.trim() || '';
    const channel = document.getElementById('channel')?.value?.trim() || '';
    const receiver = document.getElementById('receiver')?.value?.trim() || '';
    const buttonKey = document.getElementById('buttonKey')?.value?.trim() || '';
    const quantity = Math.max(1, safeParseInt(document.getElementById('quantity')?.value, 1));
    const additionalInfo = document.getElementById('additionalInfo')?.value?.trim() || '';

    const uniqueId = generateUniqueId();
    const newEffect = {
      id: uniqueId,
      name: name,
      effectType: effectType,
      plannedDuration: plannedDuration,
      price: price,
      barcode: barcode,
      time: parseTime(time),
      timeStr: time,
      channel: channel,
      receiver: receiver,
      buttonKey: buttonKey,
      quantity: quantity,
      additionalInfo: additionalInfo,
      image: currentEffectImage || null,
      video: currentEffectVideo || null,
      x: null,
      y: null,
      createdAt: new Date().toISOString()
    };

    backup = [...effects];
    const oldLength = effects.length;
    effects.push(newEffect);
    const newLength = effects.length;
    if (newLength !== oldLength + 1) throw new Error(`Array-Länge stimmt nicht! Erwartet: ${oldLength + 1}, Erhalten: ${newLength}`);
    const lastEffect = effects[effects.length - 1];
    if (!lastEffect || lastEffect.id !== uniqueId) throw new Error('Letzter Effekt stimmt nicht überein!');

    // clear form
    try {
      nameField.value = ''; timeField.value = '';
      ['plannedDuration','price','barcode','channel','receiver','buttonKey','quantity','additionalInfo','stockQuantity'].forEach(id => {
        const f = document.getElementById(id); if (f) f.value = '';
      });
      clearImage(); clearVideo();
    } catch (e) { console.warn('Form clearing warning:', e); }

    updateEffectList(); updateCostCalculation(); drawCanvas(); checkInventoryWarnings();
    saveEffectsToStorage(); // persist
    showSuccessMessage(`✅ "${escapeHtml(name)}" erfolgreich gespeichert! Show hat jetzt ${effects.length} Effekte`);

    const saveButton = document.querySelector('button[onclick="addEffect()"]');
    if (saveButton) {
      const originalText = saveButton.textContent; const originalBg = saveButton.style.background;
      saveButton.textContent = '✅ Gespeichert!'; saveButton.style.background = '#4caf50'; saveButton.style.transform = 'scale(1.05)';
      setTimeout(() => { saveButton.textContent = originalText; saveButton.style.background = originalBg; saveButton.style.transform = 'scale(1)'; }, 2000);
    }
    return true;
  } catch (error) {
    console.error('KRITISCHER FEHLER in addEffect():', error);
    try { if (Array.isArray(backup)) { effects.length = 0; effects.push(...backup); saveEffectsToStorage(); console.log('Backup wiederhergestellt'); } } catch (rollbackError) { console.error('Rollback fehlgeschlagen:', rollbackError); }
    alert('Fehler beim Speichern des Effekts!\n\nFehler: ' + (error.message || error));
    return false;
  }
}

// ===== Update list, overview, cost =====
function updateEffectList() {
  try {
    const list = document.getElementById('effectList'); if (!list) return;
    list.innerHTML = '<h3>Effekte in der Show</h3>';
    if (!Array.isArray(effects)) { effects = []; return; }
    effects.sort((a,b) => (a.time||0) - (b.time||0));
    effects.forEach(effect => {
      if (!effect || !effect.id) return;
      try {
        const div = document.createElement('div'); div.className = 'effect-item'; div.draggable = true;
        const dbEffect = effectDatabase.find(e => (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode));
        if (dbEffect && typeof dbEffect.stockQuantity === 'number') {
          if (dbEffect.stockQuantity === 0) div.classList.add('out-of-stock');
          else if (dbEffect.stockQuantity < (effect.quantity || 1)) div.classList.add('low-stock');
        }
        const safeName = escapeHtml(effect.name || 'Unbenannt');
        const safeTimeStr = escapeHtml(effect.timeStr || '0:00');
        const safeEffectType = escapeHtml(effect.effectType || 'rocket');
        const safeChannel = escapeHtml(effect.channel || 'Nicht gesetzt');
        const safeButtonKey = escapeHtml(effect.buttonKey || 'Nicht gesetzt');
        const safePrice = (effect.price && effect.price > 0) ? safeParseFloat(effect.price).toFixed(2) : '0.00';
        const safeQuantity = Math.max(1, safeParseInt(effect.quantity, 1));
        const positionText = (effect.x !== null && effect.y !== null) ? `X:${Math.round(effect.x)}, Y:${Math.round(effect.y)}` : 'Nicht platziert';
        const stockText = (dbEffect && typeof dbEffect.stockQuantity === 'number') ? `<br>Lager: ${dbEffect.stockQuantity}x` : '';
        const ignitionText = (effect.ignitionBox && effect.ignitionChannel) ? `<br><span style="color: #00ffff;">📡 Box ${escapeHtml(effect.ignitionBox)}-${escapeHtml(effect.ignitionChannel)}</span>` : '';
        div.innerHTML = `
          <div style="display: flex; align-items: center;">
            ${effect.image ? `<img src="${effect.image}" class="effect-image" alt="Effekt" onerror="this.style.display='none';">` : ''}
            ${effect.video ? `<video src="${effect.video}" class="effect-video" muted onerror="this.style.display='none';"></video>` : ''}
            <div>
              <strong>${safeName}</strong><br>
              Zeit: ${safeTimeStr} | Typ: ${safeEffectType}<br>
              Kanal: ${safeChannel} | Taste: ${safeButtonKey}<br>
              Preis: ${safePrice}€ | Anzahl: ${safeQuantity}<br>
              Position: ${positionText}${stockText}${ignitionText}
            </div>
          </div>
          <div style="display: flex; gap: 5px;">
            <button onclick="selectEffectForIgnition('${effect.id}')" style="background: #ff9800; color: white; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Zu Zündanlage zuweisen">📡</button>
            <button class="effect-edit" onclick="editEffect('${effect.id}')" style="background: #2196f3; color: white; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">✏️</button>
            <button class="effect-delete" onclick="deleteEffect('${effect.id}')">×</button>
          </div>
        `;
        div.addEventListener('dragstart', function(e){ draggedEffect = effect; div.classList.add('dragging'); });
        div.addEventListener('dragend', function(e){ div.classList.remove('dragging'); saveEffectsToStorage(); });
        list.appendChild(div);
      } catch (itemError) { console.error('Fehler beim Erstellen des Effekt-Items:', itemError, effect); }
    });
  } catch (error) { console.error('Fehler beim Aktualisieren der Effekt-Liste:', error); }
}
function updateCostCalculation() {
  try {
    let totalCost = 0; let totalEffects = 0;
    if (Array.isArray(effects)) {
      effects.forEach(effect => {
        if (effect && typeof effect === 'object') {
          const price = safeParseFloat(effect.price);
          const quantity = Math.max(1, safeParseInt(effect.quantity, 1));
          totalCost += price * quantity; totalEffects += quantity;
        }
      });
    }
    const totalCostElement = document.getElementById('totalCost');
    const effectCountElement = document.getElementById('effectCount');
    if (totalCostElement) totalCostElement.textContent = `Gesamtkosten: ${totalCost.toFixed(2)} €`;
    if (effectCountElement) effectCountElement.textContent = `Anzahl Effekte: ${totalEffects}`;
    updateEffectOverview();
  } catch (error) { console.error('Fehler bei Kostenberechnung:', error); }
}
function updateEffectOverview() {
  try {
    const overviewDiv = document.getElementById('overviewTable'); if (!overviewDiv) return;
    if (!Array.isArray(effects) || effects.length === 0) { overviewDiv.innerHTML = '<p style="color: #666; font-style: italic;">Keine Effekte in der Show</p>'; return; }
    const sortedEffects = [...effects].sort((a,b)=> (a.time||0)-(b.time||0));
    let html = `<table class="overview-table"><thead><tr><th>Zeit</th><th>Effekt</th><th>Typ</th><th>Dauer</th><th>Kanal</th><th>Taste</th><th>Empfänger</th><th>Preis</th><th>Anzahl</th><th>Lager</th></tr></thead><tbody>`;
    sortedEffects.forEach(effect => {
      if (!effect) return;
      try {
        const dbEffect = effectDatabase.find(e => (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode));
        const stockInfo = (dbEffect && typeof dbEffect.stockQuantity === 'number') ? dbEffect.stockQuantity : '-';
        const safeName = escapeHtml(effect.name || 'Unbenannt');
        const safeTimeStr = escapeHtml(effect.timeStr || '0:00');
        const safeEffectType = escapeHtml(effect.effectType || 'rocket');
        const safeDuration = escapeHtml(effect.plannedDuration || '-');
        const safeChannel = escapeHtml(effect.channel || '-');
        const safeButtonKey = escapeHtml(effect.buttonKey || '-');
        const safeReceiver = escapeHtml(effect.receiver || '-');
        const safePrice = (effect.price && effect.price > 0) ? safeParseFloat(effect.price).toFixed(2) + '€' : '-';
        const safeQuantity = Math.max(1, safeParseInt(effect.quantity, 1));
        const stockColor = stockInfo === 0 ? '#f44336' : (stockInfo <= 5 && stockInfo !== '-' ? '#ff9800' : '#4caf50');
        html += `<tr><td class="time-cell">${safeTimeStr}</td><td><strong>${safeName}</strong></td><td>${safeEffectType}</td><td>${safeDuration}</td><td class="channel-cell">${safeChannel}</td><td class="button-cell">${safeButtonKey}</td><td>${safeReceiver}</td><td>${safePrice}</td><td>${safeQuantity}</td><td style="color: ${stockColor}">${stockInfo}</td></tr>`;
      } catch (rowError) { console.error('Fehler beim Erstellen der Tabellenzeile:', rowError, effect); }
    });
    html += '</tbody></table>'; overviewDiv.innerHTML = html;
  } catch (error) { console.error('Fehler bei Effekt-Übersicht:', error); }
}

// ===== DB functions (implemented) =====
function addToDatabase() {
  try {
    const name = (document.getElementById('name')?.value || '').trim();
    if (!name) { alert('Bitte erst einen Effektnamen eingeben.'); return; }
    const entry = {
      id: generateUniqueId(),
      name,
      barcode: (document.getElementById('barcode')?.value || '').trim(),
      price: safeParseFloat(document.getElementById('price')?.value),
      effectType: document.getElementById('effectType')?.value || 'rocket',
      plannedDuration: (document.getElementById('plannedDuration')?.value || '').trim(),
      stockQuantity: (function(){ const v=document.getElementById('stockQuantity')?.value; return v===''? null : safeParseInt(v,0); })(),
      image: currentEffectImage || null,
      video: currentEffectVideo || null,
      createdAt: new Date().toISOString()
    };
    effectDatabase.push(entry);
    saveDB();
    updateDatabaseList();
    checkInventoryWarnings();
    showSuccessMessage(`✅ "${escapeHtml(entry.name)}" zur Datenbank hinzugefügt`);
  } catch (e) { console.error('addToDatabase',e); alert('Fehler beim Hinzufügen zur DB: '+e.message); }
}
function clearDatabase() {
  try {
    if (!confirm('Datenbank wirklich leeren?')) return;
    effectDatabase = [];
    saveDB();
    updateDatabaseList();
    showSuccessMessage('✅ Effekt-Datenbank geleert');
  } catch (e) { console.error('clearDatabase', e); alert('Fehler beim Leeren der DB: '+e.message); }
}
function importExcelDatabase() {
  try {
    const fileInput = document.getElementById('excelImport');
    const file = fileInput?.files?.[0];
    if (!file) { alert('Bitte eine CSV/TSV-Datei auswählen.'); return; }
    const reader = new FileReader();
    reader.onload = function(ev) {
      try {
        const text = ev.target.result;
        const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
        const entries = [];
        lines.forEach(line => {
          const parts = line.split(/\s*\|\s*|\s*;\s*|\t|,/);
          const name = (parts[0]||'').trim(); if(!name) return;
          const barcode = (parts[1]||'').trim();
          const duration = (parts[2]||'').trim();
          const price = safeParseFloat(parts[3],0);
          const type = (parts[4]||'rocket').trim();
          const stock = parts[5]!==undefined ? safeParseInt(parts[5], null) : null;
          entries.push({ id: generateUniqueId(), name, barcode, duration, price, effectType: type, stockQuantity: stock, createdAt: new Date().toISOString() });
        });
        if (entries.length===0) { alert('Keine Einträge gefunden'); return; }
        effectDatabase.push(...entries);
        saveDB();
        updateDatabaseList();
        checkInventoryWarnings();
        showSuccessMessage(`✅ ${entries.length} Effekte importiert`);
      } catch(e) { console.error('import processing',e); alert('Import-Fehler: '+e.message); }
    };
    reader.readAsText(file,'utf-8');
  } catch(e) { console.error('importExcelDatabase',e); alert('Import-Fehler: '+e.message); }
}

// ===== Image/Video handling =====
function previewVideo() {
  try {
    const fileInput = document.getElementById('effectVideo');
    const file = fileInput?.files?.[0];
    const previewDiv = document.getElementById('videoPreview');
    if (!previewDiv) return;
    if (file) {
      const url = URL.createObjectURL(file);
      const reader = new FileReader();
      reader.onload = function(e) { currentEffectVideo = e.target.result; previewDiv.innerHTML = `<video class="video-preview" controls muted onerror="this.style.display='none';"><source src="${url}" type="${file.type}">Ihr Browser unterstützt keine Videos.</video>`; };
      reader.readAsDataURL(file);
    } else clearVideo();
  } catch (error) { console.error('Fehler bei Video-Vorschau:', error); }
}
function clearVideo() {
  try { currentEffectVideo = null; const previewDiv = document.getElementById('videoPreview'); const fileInput = document.getElementById('effectVideo'); if (previewDiv) previewDiv.innerHTML=''; if (fileInput) fileInput.value=''; } catch(e){console.error('Fehler beim Video-Löschen:',e);}
}
function previewImage() {
  try {
    const fileInput = document.getElementById('effectImage');
    const file = fileInput?.files?.[0];
    const previewDiv = document.getElementById('imagePreview');
    if (!previewDiv) return;
    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) { currentEffectImage = e.target.result; previewDiv.innerHTML = `<img src="${currentEffectImage}" class="image-preview" alt="Effekt Vorschau" onerror="this.style.display='none';">`; };
      reader.readAsDataURL(file);
    } else clearImage();
  } catch (error) { console.error('Fehler bei Bild-Vorschau:', error); }
}
function clearImage() {
  try { currentEffectImage = null; const previewDiv = document.getElementById('imagePreview'); const fileInput = document.getElementById('effectImage'); if (previewDiv) previewDiv.innerHTML=''; if (fileInput) fileInput.value=''; } catch(e){console.error('Fehler beim Bild-Löschen:',e);}
}

// ===== Canvas draw =====
function drawCanvas() {
  try {
    if (!ctx || !canvas) { console.warn('Canvas oder Kontext nicht verfügbar'); return; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
    for (let x=0;x<=canvas.width;x+=50){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    for (let y=0;y<=canvas.height;y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
    drawIgnitionBoxes();
    if (Array.isArray(beatTimes) && beatTimes.length>0) {
      ctx.strokeStyle='#ff9800'; ctx.lineWidth=2; const maxMarkers = Math.min(10, beatTimes.length);
      for (let i=0;i<maxMarkers;i++){ const x=(i/maxMarkers)*canvas.width; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    }
    if (isCollaborating) drawCollaborationCursors();
    if (Array.isArray(effects)) {
      effects.forEach(effect => {
        if (!effect || typeof effect.x !== 'number' || typeof effect.y !== 'number') return;
        try {
          const colors = { rocket:'#ff4444', fountain:'#44ff44', battery:'#4444ff' };
          const dbEffect = effectDatabase.find(e => (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode));
          let effectColor = colors[effect.effectType] || '#ffffff';
          if (dbEffect && typeof dbEffect.stockQuantity === 'number') {
            if (dbEffect.stockQuantity === 0) effectColor = '#666666';
            else if (dbEffect.stockQuantity < (effect.quantity || 1)) effectColor = '#ff9800';
          }
          ctx.fillStyle = effectColor; ctx.beginPath(); ctx.arc(effect.x, effect.y, 8, 0, 2*Math.PI); ctx.fill();
          if (effect.image) { ctx.fillStyle='#ffff00'; ctx.font='16px Arial'; ctx.fillText('📸', effect.x-8, effect.y-12); }
          if (effect.video) { ctx.fillStyle='#ff00ff'; ctx.font='16px Arial'; ctx.fillText('🎬', effect.x+8, effect.y-12); }
          ctx.fillStyle='#ffffff'; ctx.font='12px Arial'; ctx.fillText(escapeHtml(effect.name || 'Effekt'), effect.x+12, effect.y+4); ctx.fillText(escapeHtml(effect.timeStr || '0:00'), effect.x+12, effect.y+16);
          if (effect.ignitionBox && effect.ignitionChannel) { ctx.fillStyle='#00ffff'; ctx.fillText(`${escapeHtml(effect.ignitionBox)}${escapeHtml(effect.ignitionChannel)}`, effect.x+12, effect.y+28); }
          else if (effect.channel && effect.buttonKey) { ctx.fillStyle='#00ffff'; ctx.fillText(`K${escapeHtml(effect.channel)}-T${escapeHtml(effect.buttonKey)}`, effect.x+12, effect.y+28); }
          if (effect.price && effect.price>0) { ctx.fillStyle='#90ee90'; ctx.fillText(`${safeParseFloat(effect.price).toFixed(2)}€`, effect.x+12, effect.y+40); }
          if (dbEffect && typeof dbEffect.stockQuantity==='number' && dbEffect.stockQuantity < (effect.quantity||1)) { ctx.fillStyle='#ff0000'; ctx.font='bold 10px Arial'; ctx.fillText('⚠️', effect.x-15, effect.y-15); }
        } catch (effectError) { console.error('Fehler beim Zeichnen des Effekts:', effectError, effect); }
      });
    }
    const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);
    if (unplacedEffects.length>0) {
      ctx.fillStyle='#ffff00'; ctx.font='bold 16px Arial'; ctx.fillText(`${unplacedEffects.length} Effekt(e) noch nicht platziert`, 20,30); ctx.font='14px Arial'; ctx.fillText('Klicke auf das Abbrennfeld um sie zu platzieren', 20,50);
      if (unplacedEffects[0]) { ctx.fillStyle='#ff8800'; ctx.fillText(`Nächster: "${escapeHtml(unplacedEffects[0].name || 'Effekt')}"`, 20,70); }
    }
    if (Array.isArray(beatTimes) && beatTimes.length>0) { ctx.fillStyle='#ff9800'; ctx.font='12px Arial'; ctx.fillText(`🎵 ${beatTimes.length} Beats | ${bpm} BPM`, canvas.width-150, 20); }
    if (isCollaborating) { ctx.fillStyle='#2196f3'; ctx.font='12px Arial'; ctx.fillText('👥 Team-Modus aktiv', canvas.width-150, canvas.height-10); }
  } catch (error) { console.error('Fehler beim Zeichnen des Canvas:', error); }
}

function drawIgnitionBoxes() {
  try {
    Object.keys(ignitionBoxPositions).forEach(boxName => {
      const pos = ignitionBoxPositions[boxName];
      const box = ignitionBoxes[boxName] || {};
      const assignedChannels = Object.keys(box).length;
      const isDragging = (isDraggingBox && draggedBox === boxName);
      let bgColor = assignedChannels > 0 ? '#1a4d1a' : '#2a2a2a';
      if (isDragging) bgColor = '#4a4a00';
      ctx.fillStyle = bgColor; ctx.fillRect(pos.x-25,pos.y-15,50,30);
      let borderColor = assignedChannels>0 ? '#4caf50' : '#666'; if (isDragging) borderColor = '#ffff00';
      ctx.strokeStyle = borderColor; ctx.lineWidth = isDragging ? 3 : 2; ctx.strokeRect(pos.x-25,pos.y-15,50,30);
      if (!isDragging) { ctx.fillStyle='#888'; ctx.font='8px Arial'; ctx.textAlign='right'; ctx.fillText('⋮⋮', pos.x+22, pos.y-8); }
      ctx.fillStyle='#ffffff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.fillText(`📡${boxName}`, pos.x, pos.y-2);
      ctx.font='10px Arial'; ctx.fillStyle = assignedChannels>0 ? '#4caf50' : '#999'; ctx.fillText(`${assignedChannels}/32`, pos.x, pos.y+10);
      if (assignedChannels>0) { ctx.fillStyle='#4caf50'; ctx.beginPath(); ctx.arc(pos.x+20, pos.y-10, 3,0,2*Math.PI); ctx.fill(); }
      if (assignedChannels>0) {
        ctx.font='8px Arial'; ctx.fillStyle='#ffff00'; let yOffset=25;
        const sortedChannels = Object.keys(box).sort((a,b)=>parseInt(a)-parseInt(b)).slice(0,3);
        sortedChannels.forEach(channel => { const effect = box[channel]; if (effect) { ctx.fillText(`${channel}:${escapeHtml(effect.name.substring(0,8))}`, pos.x, pos.y+yOffset); yOffset+=10; }});
        if (assignedChannels>3) ctx.fillText(`+${assignedChannels-3} mehr`, pos.x, pos.y+yOffset);
      }
    });
    ctx.textAlign='left';
  } catch (error) { console.error('Fehler beim Zeichnen der Zündboxen:', error); }
}
function drawCollaborationCursors() {
  try {
    if (Array.isArray(collaborators) && collaborators.length>0) {
      collaborators.forEach((collaborator, index) => {
        if (!collaborator || typeof collaborator.x!=='number' || typeof collaborator.y!=='number') return;
        ctx.fillStyle = `hsl(${index*60},70%,50%)`; ctx.beginPath(); ctx.arc(collaborator.x, collaborator.y, 5,0,2*Math.PI); ctx.fill();
        ctx.fillStyle='#ffffff'; ctx.font='10px Arial'; ctx.fillText(escapeHtml(collaborator.name||'User'), collaborator.x+10, collaborator.y-10);
      });
    }
  } catch (error) { console.error('Fehler beim Zeichnen der Kollaborations-Cursor:', error); }
}

// ===== Zündanlagen / Auswahl / Assign / Remove =====
function selectEffectForIgnition(effectId) {
  try {
    selectedEffect = effects.find(e => e && e.id===effectId);
    if (selectedEffect) {
      updateCurrentSelection();
      const ignitionBox = document.querySelector('#ignitionBox');
      if (ignitionBox) {
        ignitionBox.scrollIntoView({ behavior: 'smooth' });
        const section = ignitionBox.closest('div[style*="background: #1a1a2e"]');
        if (section) { section.style.boxShadow='0 0 20px rgba(76,175,80,0.5)'; setTimeout(()=>{ section.style.boxShadow=''; },3000); }
      }
    }
  } catch (error) {
