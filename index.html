<!DOCTYPE html>

<html lang="de">

<head>

<meta charset="UTF-8">

<title>🎆 FirePlanner 2D - Pro Advanced (Korrigiert)</title>

<style>

body {

  box-sizing: border-box;

  font-family: Arial, sans-serif;

  margin: 0;

  background: #111;

  color: #eee;

}

h1, h2 {

  text-align: center;

  margin: 10px 0;

}

input, button, select, textarea {

  margin: 5px;

  padding: 8px;

  background: #222;

  color: #fff;

  border: 1px solid #555;

  border-radius: 5px;

  font-size: 14px;

  outline: none;

}


input:focus, textarea:focus, select:focus {

  background: #333;

  border-color: #4caf50;

  box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);

}


input[type="text"], input[type="number"], textarea {

  width: 200px;

  max-width: 100%;

}

button {

  cursor: pointer;

  background: #444;

  transition: 0.2s;

  padding: 10px 15px;

}

button:hover {

  background: #666;

}

#container {

  display: flex;

  flex-wrap: wrap;

  justify-content: center;

  gap: 20px;

}

#effectList {

  max-width: 400px;

  margin: 10px;

}

.effect-item {

  border: 1px solid #555;

  padding: 10px;

  margin: 8px 0;

  border-radius: 5px;

  background: #222;

  cursor: move;

  display: flex;

  justify-content: space-between;

  align-items: center;

  transition: all 0.2s;

}

.effect-item:hover {

  background: #333;

  transform: translateY(-2px);

}

.effect-item.dragging {

  opacity: 0.5;

  transform: rotate(5deg);

}

.effect-item.low-stock {

  border-color: #ff9800;

  background: #2d1b0f;

}

.effect-item.out-of-stock {

  border-color: #f44336;

  background: #2d0f0f;

}

#canvasContainer {

  position: relative;

  margin: 10px auto;

  border: 2px solid #555;

  background: #000;

  border-radius: 8px;

}

#fireworkCanvas {

  cursor: crosshair;

  display: block;

  border-radius: 6px;

}

.tooltip {

  position: relative;

  display: inline-block;

}

.tooltip .tooltiptext {

  visibility: hidden;

  width: 200px;

  background: #333;

  color: #fff;

  text-align: left;

  border-radius: 5px;

  padding: 8px;

  position: absolute;

  z-index: 1;

  bottom: 125%;

  left: 50%;

  margin-left: -100px;

  opacity: 0;

  transition: opacity 0.3s;

}

.tooltip:hover .tooltiptext {

  visibility: visible;

  opacity: 1;

}

#timerDisplay {

  font-size: 3em;

  text-align: center;

  margin: 20px 0;

  font-weight: bold;

  color: #0ff;

}

#currentEffect {

  font-size: 1.4em;

  color: #ff0;

  text-align: center;

  margin: 15px 0;

  padding: 10px;

  background: #222;

  border-radius: 5px;

  min-height: 60px;

}

#warning {

  font-size: 2.5em;

  color: #f00;

  text-align: center;

  margin: 15px 0;

  font-weight: bold;

}

#timelineDisplay {

  text-align: center;

  margin: 15px 0;

  padding: 10px;

  background: #222;

  border-radius: 5px;

}

#printArea {

  display: none;

}

#warningFlash {

  position: absolute;

  top: 0;

  left: 0;

  width: 100%;

  height: 100%;

  background: red;

  opacity: 0;

  pointer-events: none;

  border-radius: 5px;

  transition: opacity 0.1s;

}

.controls {

  text-align: center;

  margin: 20px 0;

  padding: 15px;

  background: #222;

  border-radius: 8px;

}

.effect-delete {

  background: #d32f2f;

  color: white;

  border: none;

  padding: 5px 8px;

  border-radius: 3px;

  cursor: pointer;

  font-size: 12px;

}

.effect-delete:hover {

  background: #b71c1c;

}

#costCalculation {

  text-align: center;

  margin: 20px 0;

  padding: 15px;

  background: #1a4d1a;

  border-radius: 8px;

  border: 2px solid #2e7d32;

}

#costCalculation h3 {

  margin: 0 0 10px 0;

  color: #4caf50;

}

#totalCost {

  font-size: 1.5em;

  font-weight: bold;

  color: #81c784;

}

#effectCount {

  color: #a5d6a7;

  margin-top: 5px;

}

.explosion {

  position: absolute;

  pointer-events: none;

  border-radius: 50%;

  animation: explode 1s ease-out forwards;

}

@keyframes explode {

  0% { transform: scale(0); opacity: 1; }

  50% { transform: scale(1.5); opacity: 0.8; }

  100% { transform: scale(3); opacity: 0; }

}

#qrModal {

  display: none;

  position: fixed;

  z-index: 1000;

  left: 0;

  top: 0;

  width: 100%;

  height: 100%;

  background-color: rgba(0,0,0,0.8);

}

.modal-content {

  background-color: #222;

  margin: 15% auto;

  padding: 20px;

  border: 1px solid #555;

  border-radius: 10px;

  width: 300px;

  text-align: center;

}

.close {

  color: #aaa;

  float: right;

  font-size: 28px;

  font-weight: bold;

  cursor: pointer;

}

.close:hover {

  color: #fff;

}

#backupStatus {

  position: fixed;

  top: 20px;

  right: 20px;

  background: #4caf50;

  color: white;

  padding: 10px;

  border-radius: 5px;

  display: none;

  z-index: 1000;

}

#effectOverview {

  text-align: center;

  margin: 20px 0;

  padding: 15px;

  background: #1a1a2e;

  border-radius: 8px;

  border: 2px solid #16213e;

}

#effectOverview h3 {

  margin: 0 0 15px 0;

  color: #0f3460;

}

#overviewTable {

  overflow-x: auto;

}

.overview-table {

  width: 100%;

  border-collapse: collapse;

  background: #222;

  border-radius: 5px;

  overflow: hidden;

}

.overview-table th {

  background: #333;

  color: #fff;

  padding: 10px 8px;

  text-align: left;

  font-size: 12px;

  border-bottom: 2px solid #555;

}

.overview-table td {

  padding: 8px;

  border-bottom: 1px solid #444;

  font-size: 11px;

  color: #ddd;

}

.overview-table tr:hover {

  background: #2a2a2a;

}

.time-cell {

  color: #4caf50;

  font-weight: bold;

}

.channel-cell {

  color: #2196f3;

  font-weight: bold;

}

.button-cell {

  color: #ff9800;

  font-weight: bold;

}

.database-info {

  background: #2a2a2a;

  padding: 10px;

  border-radius: 5px;

  margin: 10px 0;

  font-size: 12px;

  color: #ccc;

}

.image-preview {

  max-width: 200px;

  max-height: 150px;

  border-radius: 5px;

  border: 2px solid #555;

  margin: 10px 0;

}

.video-preview {

  max-width: 200px;

  max-height: 150px;

  border-radius: 5px;

  border: 2px solid #555;

  margin: 10px 0;

}

.effect-image {

  max-width: 50px;

  max-height: 50px;

  border-radius: 3px;

  margin-right: 10px;

  vertical-align: middle;

}

.effect-video {

  max-width: 50px;

  max-height: 50px;

  border-radius: 3px;

  margin-right: 10px;

  vertical-align: middle;

}

.database-item {

  display: flex;

  align-items: center;

  padding: 5px;

  margin: 2px 0;

  background: #333;

  border-radius: 3px;

}

.database-item img {

  margin-right: 10px;

}

#inventoryWarning {

  display: none;

  background: #d32f2f;

  color: white;

  padding: 15px;

  margin: 20px 0;

  border-radius: 8px;

  text-align: center;

}

#inventoryWarning h3 {

  margin: 0 0 10px 0;

}

#beatInfo {

  margin: 10px 0;

  padding: 10px;

  background: #1a1a2e;

  border-radius: 5px;

  display: none;

}

#collaborationStatus {

  position: fixed;

  top: 60px;

  right: 20px;

  background: #2196f3;

  color: white;

  padding: 10px;

  border-radius: 5px;

  display: none;

  z-index: 1000;

}

.beat-marker {

  position: absolute;

  width: 2px;

  height: 100%;

  background: #ff9800;

  opacity: 0.7;

  pointer-events: none;

}

.collaboration-cursor {

  position: absolute;

  width: 20px;

  height: 20px;

  border-radius: 50%;

  pointer-events: none;

  z-index: 100;

  transition: all 0.1s;

}


/* Verstecke alle interaktiven Elemente beim Drucken */

@media print {

  button, select, input, textarea, .effect-delete, .effect-edit { display: none !important; }

  #effectList h3, #effectList .effect-item button { display: none !important; }

  .controls, #container > #effectList { display: none !important; }

  #planScreen > h2:not(.print-keep), #planScreen > div:not(#printArea):not(#effectOverview):not(#costCalculation):not(.print-keep) { display: none !important; }

  #planScreen > input, #planScreen > select, #planScreen > button { display: none !important; }

  #planScreen > br { display: none !important; }

  .database-info { display: none !important; }

 

  /* Verstecke spezifische Bearbeitungsbereiche */

  #planScreen > div[style*="display: grid"],

  #planScreen > div[style*="display: flex"],

  #planScreen > div[style*="margin: 10px 0"]:not(#effectOverview):not(#costCalculation):not(#inventoryWarning) { display: none !important; }

 

  /* Verstecke alle Formularbereiche */

  #planScreen > div:has(input),

  #planScreen > div:has(select),

  #planScreen > div:has(button),

  #planScreen > div:has(textarea) { display: none !important; }

 

  /* Verstecke Dropdown-Menüs und Eingabefelder */

  .effect-item select, .effect-item input, .effect-item button { display: none !important; }

 

  /* Verstecke Bearbeitungshinweise */

  .database-info, .beat-info, #beatInfo { display: none !important; }

 

  /* Verstecke Kollaborations-Status */

  #collaborationStatus, #backupStatus { display: none !important; }

 

  /* Zeige nur relevante Bereiche */

  #printArea { display: block !important; }

  #effectOverview { display: block !important; }

  #costCalculation { display: block !important; }

 

  /* Verbessere Tabellen-Layout */

  .overview-table th { background-color: #f0f0f0 !important; color: #000 !important; }

  .overview-table td { color: #000 !important; }

 

  /* Seitenumbrüche optimieren */

  .summary { page-break-inside: avoid; }

  .inventory-warning { page-break-inside: avoid; }

  table { page-break-inside: auto; }

  tr { page-break-inside: avoid; page-break-after: auto; }

 

  /* Verstecke Scrollbalken */

  * { overflow: visible !important; }

}

</style>

</head>

<body>


<h1>🎆 FirePlanner 2D - Pro Advanced (Korrigiert)</h1>


<div id="planScreen">

<h2>Show-Name</h2>

<input id="showName" placeholder="Name der Show">


<h2>Effekt hinzufügen</h2>

<select id="effectSavedList" onchange="selectSavedEffect()">

  <option value="">Vorherige Effekte</option>

</select>

<div style="position: relative; display: inline-block;">

  <select id="effectDatabase" onchange="selectFromDatabase()">

    <option value="">Effekt-Datenbank</option>

  </select>

  <input type="text" id="effectSearch" placeholder="🔍 Effekt suchen..."

         style="display: none; position: absolute; top: 0; left: 0; width: 100%; z-index: 10;"

         onkeyup="searchEffects()" onblur="hideSearch()">

</div>

<button onclick="showSearch()" id="searchButton" style="display: none;">🔍 Suchen</button><br>


<div class="database-info">

  📊 <strong>Excel-Import Format:</strong> Name | Barcode | Dauer | Preis | Typ | Lagerbestand<br>

  Beispiel: "Goldener Regen | 4260123456789 | 0:15 | 12.50 | rocket | 25"<br>

  📸 <strong>Bilder & Videos:</strong> Optional - können einzeln hochgeladen werden

</div>


<h3>📸 Bild für Effekt (Optional)</h3>

<input type="file" id="effectImage" accept="image/*" onchange="previewImage()">

<div id="imagePreview" style="margin: 10px 0;"></div>

<button onclick="clearImage()">🗑️ Bild entfernen</button>


<h3>🎬 Video-Vorschau (Optional)</h3>

<input type="file" id="effectVideo" accept="video/*" onchange="previewVideo()">

<div id="videoPreview" style="margin: 10px 0;"></div>

<button onclick="clearVideo()">🗑️ Video entfernen</button>


<input id="name" placeholder="Effektname">

<select id="effectType">

  <option value="rocket">Rakete</option>

  <option value="fountain">Fontäne</option>

  <option value="battery">Batterie</option>

</select>

<input id="plannedDuration" placeholder="Dauer (m:s)">

<input id="price" placeholder="Preis (€)" type="number" step="0.01">

<input id="barcode" placeholder="Barcode/EAN">

<input id="time" placeholder="Showzeit (m:s)">

<input id="channel" placeholder="Kanal" type="number" min="1">

<input id="receiver" placeholder="Empfänger">

<input id="buttonKey" placeholder="Taste">

<input id="quantity" placeholder="Anzahl Effekte">

<input id="stockQuantity" placeholder="Lagerbestand" type="number">

<textarea id="additionalInfo" placeholder="Zusatzinfos"></textarea>

<button onclick="addEffect()">Effekt speichern</button>

<button onclick="addToDatabase()">Zur Datenbank hinzufügen</button>

<input type="file" id="excelImport" accept=".csv,.txt,.tsv" onchange="importExcelDatabase()">

<button onclick="document.getElementById('excelImport').click()">📊 Excel-Datenbank importieren</button>

<button onclick="clearDatabase()">🗑️ Datenbank leeren</button>


<div id="container">

  <div id="canvasContainer">

    <canvas id="fireworkCanvas" width="800" height="500"></canvas>

    <div id="warningFlash"></div>

  </div>

  <div id="effectList"></div>

</div>


<div id="costCalculation">

  <h3>💰 Kostenkalkulation</h3>

  <div id="totalCost">Gesamtkosten: 0,00 €</div>

  <div id="effectCount">Anzahl Effekte: 0</div>

</div>


<div id="inventoryWarning">

  <h3>⚠️ Lagerbestand-Warnung</h3>

  <div id="lowStockItems"></div>

</div>


<div id="effectOverview">

  <h3>📋 Effekt-Übersicht</h3>

  <div id="overviewTable"></div>

</div>


<h2>🎵 Musik & Beat-Sync</h2>

<input type="file" id="musicFile" accept="audio/*" onchange="loadMusic()">

<button onclick="analyzeBeat()" id="beatAnalyzeBtn" style="display: none;">🎵 Beat analysieren</button>

<button onclick="autoSyncEffects()" id="autoSyncBtn" style="display: none;">⚡ Auto-Sync zu Beats</button>

<div id="beatInfo">

  <strong>🎵 Beat-Analyse:</strong><br>

  <span id="bpmDisplay">BPM: Nicht analysiert</span><br>

  <span id="beatCount">Beats gefunden: 0</span>

</div>


<h2>📡 Zündanlagen-Verwaltung</h2>

<div style="background: #1a1a2e; padding: 20px; border-radius: 8px; border: 2px solid #16213e; margin: 20px 0;">

  <h3 style="color: #4caf50; margin: 0 0 15px 0;">🎯 Effekt zu Zündbox zuweisen</h3>

 

  <div id="currentSelection" style="background: #222; padding: 15px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #4caf50;">

    <p style="color: #666; font-style: italic;">Kein Effekt ausgewählt</p>

  </div>

 

  <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">

    <div>

      <label style="color: #ccc; display: block; margin: 0 0 5px;">📡 Zündbox auswählen:</label>

      <select id="ignitionBox" onchange="selectIgnitionBox()" style="width: 100%; padding: 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">

        <option value="">Box wählen</option>

        <option value="A">Box A (32 Kanäle)</option>

        <option value="B">Box B (32 Kanäle)</option>

        <option value="C">Box C (32 Kanäle)</option>

        <option value="D">Box D (32 Kanäle)</option>

        <option value="E">Box E (32 Kanäle)</option>

        <option value="F">Box F (32 Kanäle)</option>

      </select>

    </div>

   

    <div>

      <label style="color: #ccc; display: block; margin: 0 0 5px;">🔢 Kanal (1-32):</label>

      <input id="selectedChannel" type="number" min="1" max="32" placeholder="Kanal eingeben" style="width: 100%; padding: 10px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">

    </div>

  </div>

 

  <div style="text-align: center; margin: 20px 0;">

    <button onclick="assignToBox()" style="background: #4caf50; color: white; border: none; padding: 12px 25px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">

      🎆 Effekt zu Box zuweisen

    </button>

  </div>

 

  <div style="margin: 20px 0;">

    <h4 style="color: #ff9800; margin: 0 0 10px 0;">⚡ Schnell-Zuweisung:</h4>

    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px;">

      <button onclick="quickAssign('A', 1)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">A1</button>

      <button onclick="quickAssign('A', 2)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">A2</button>

      <button onclick="quickAssign('B', 1)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">B1</button>

      <button onclick="quickAssign('B', 2)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">B2</button>

      <button onclick="quickAssign('C', 1)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">C1</button>

      <button onclick="quickAssign('C', 2)" style="background: #2196f3; color: white; border: none; padding: 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">C2</button>

    </div>

  </div>

 

  <div style="text-align: center; margin: 20px 0;">

    <button onclick="showIgnitionOverview()" style="background: #ff9800; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin: 5px;">

      📋 Zündanlagen-Übersicht anzeigen

    </button>

    <button onclick="resetBoxPositions()" style="background: #9c27b0; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; margin: 5px;">

      🔄 Box-Positionen zurücksetzen

    </button>

  </div>

</div>


<div id="ignitionOverview" style="background: #1a2e1a; padding: 20px; border-radius: 8px; border: 2px solid #2e7d32; margin: 20px 0; display: none;">

  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">

    <h3 style="color: #4caf50; margin: 0;">📡 Zündanlagen-Übersicht</h3>

    <button onclick="hideIgnitionOverview()" style="background: #666; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;">✕ Schließen</button>

  </div>

  <div id="ignitionBoxes"></div>

</div>


<h2>🌡️ Wetter-Monitor</h2>

<div style="display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0;">

  <input id="windSpeed" placeholder="Windgeschwindigkeit (km/h)" type="number">

  <select id="windDirection">

    <option value="">Windrichtung</option>

    <option value="N">Nord</option>

    <option value="NO">Nordost</option>

    <option value="O">Ost</option>

    <option value="SO">Südost</option>

    <option value="S">Süd</option>

    <option value="SW">Südwest</option>

    <option value="W">West</option>

    <option value="NW">Nordwest</option>

  </select>

  <input id="temperature" placeholder="Temperatur (°C)" type="number">

  <input id="humidity" placeholder="Luftfeuchtigkeit (%)" type="number">

  <button onclick="checkWeatherConditions()">🌤️ Wetter prüfen</button>

</div>

<div id="weatherStatus" style="margin: 10px 0; padding: 10px; border-radius: 5px; display: none;"></div>


<div class="controls">

<button onclick="saveShow()">Show speichern</button>

<button onclick="loadSavedShows()">Show laden</button>

<select id="savedShows" onchange="selectShow()">

  <option value="">Gespeicherte Shows</option>

</select>

<button onclick="exportShow()">Export JSON</button>

<input type="file" id="importFile" accept=".json" onchange="importShow()">

<button onclick="importShow()">Import JSON</button>

<button onclick="printPlan()">Druckversion</button>

<button onclick="generateQRCode()">📱 Smartphone-Steuerung</button>

<button onclick="loadFromSession()">🔗 Session laden</button>

<button onclick="startCollaboration()">👥 Team-Kollaboration</button>

<button onclick="joinCollaboration()">🤝 Team beitreten</button>

<button onclick="autoBackup()">💾 Auto-Backup</button>

<button onclick="startShow()">Show starten</button>

<button onclick="pauseShow()">Pause</button>

<button onclick="resumeShow()">Fortsetzen</button>

<button onclick="stopShow()">Stopp</button>

</div>

</div>


<div id="showScreen" style="display:none;">

<h2>Show Timer</h2>

<div id="timerDisplay">00:00</div>

<div id="warning"></div>

<div id="currentEffect"></div>

<div id="timelineDisplay"></div>

<button onclick="backToPlan()" style="margin: 20px;">Zurück zur Planung</button>

</div>


<div class="print-area" id="printArea"></div>


<!-- QR Code Modal -->

<div id="qrModal">

  <div class="modal-content">

    <span class="close" onclick="closeQRModal()">&times;</span>

    <h3>📱 Smartphone-Steuerung</h3>

    <div id="qrCode"></div>

    <p>Scanne den QR-Code mit deinem Smartphone</p>

    <div id="remoteUrl"></div>

  </div>

</div>


<div id="backupStatus">Backup erstellt!</div>

<div id="collaborationStatus">Team-Modus aktiv</div>


<audio id="warningBeep" preload="auto">

  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">

</audio>

<audio id="fireBeep" preload="auto">

  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">

</audio>

<audio id="musicPlayer"></audio>


<script>

// ===== KORRIGIERTE VERSION - ALLE FEHLER BEHOBEN =====


let effects = [];

let showTimer = null;

let showStartTime = 0;

let isPaused = false;

let pausedTime = 0;

let canvas, ctx;

let savedEffects = [];

let effectDatabase = [];

let draggedEffect = null;

let autoBackupInterval = null;

let currentEffectImage = null;

let currentEffectVideo = null;


// Zündanlagen-Variablen

let selectedEffect = null;

let ignitionBoxes = {

  A: {},

  B: {},

  C: {},

  D: {},

  E: {},

  F: {}

};


// Zündbox-Positionen (verschiebbar)

let ignitionBoxPositions = {

  A: { x: 50, y: 50 },

  B: { x: 150, y: 50 },

  C: { x: 250, y: 50 },

  D: { x: 50, y: 120 },

  E: { x: 150, y: 120 },

  F: { x: 250, y: 120 }

};


// Drag & Drop für Zündboxen

let draggedBox = null;

let dragOffset = { x: 0, y: 0 };

let isDraggingBox = false;


// Beat-Sync Variables

let audioContext = null;

let audioBuffer = null;

let beatTimes = [];

let bpm = 0;


// Collaboration Variables

let collaborationId = null;

let isCollaborating = false;

let collaborators = [];

let lastSyncTime = 0;


// Inventory Variables

let inventoryWarnings = [];


// Cleanup Variables

let intervals = [];

let eventListeners = [];


// ===== UTILITY FUNCTIONS (SICHERHEIT) =====

function escapeHtml(text) {

  if (!text) return '';

  const div = document.createElement('div');

  div.textContent = text.toString();

  return div.innerHTML;

}


function generateUniqueId() {

  return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}_${Math.floor(Math.random() * 10000)}`;

}


function safeParseInt(value, defaultValue = 0) {

  const parsed = parseInt(value);

  return isNaN(parsed) ? defaultValue : parsed;

}


function safeParseFloat(value, defaultValue = 0) {

  const parsed = parseFloat(value);

  return isNaN(parsed) ? defaultValue : parsed;

}


function addManagedInterval(callback, delay) {

  const id = setInterval(callback, delay);

  intervals.push(id);

  return id;

}


function addManagedEventListener(element, event, callback) {

  if (!element) return;

  element.addEventListener(event, callback);

  eventListeners.push({ element, event, callback });

}


function cleanup() {

  intervals.forEach(id => {

    try {

      clearInterval(id);

    } catch (e) {

      console.warn('Error clearing interval:', e);

    }

  });

  intervals = [];

 

  eventListeners.forEach(({ element, event, callback }) => {

    try {

      if (element && element.removeEventListener) {

        element.removeEventListener(event, callback);

      }

    } catch (e) {

      console.warn('Error removing event listener:', e);

    }

  });

  eventListeners = [];

}


function showSuccessMessage(message, duration = 3000) {

  const successMsg = document.createElement('div');

  successMsg.style.cssText = `

    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);

    background: linear-gradient(45deg, #4caf50, #66bb6a);

    color: white; padding: 15px 25px; border-radius: 8px;

    z-index: 10000; font-weight: bold; font-size: 16px;

    box-shadow: 0 8px 25px rgba(0,0,0,0.3);

    border: 2px solid #2e7d32;

  `;

  successMsg.textContent = message;

 

  document.body.appendChild(successMsg);

 

  // Animation

  successMsg.style.opacity = '0';

  successMsg.style.transform = 'translateX(-50%) translateY(-20px)';

  setTimeout(() => {

    successMsg.style.transition = 'all 0.3s ease';

    successMsg.style.opacity = '1';

    successMsg.style.transform = 'translateX(-50%) translateY(0)';

  }, 10);

 

  setTimeout(() => {

    successMsg.style.opacity = '0';

    successMsg.style.transform = 'translateX(-50%) translateY(-20px)';

    setTimeout(() => {

      if (successMsg.parentNode) {

        successMsg.parentNode.removeChild(successMsg);

      }

    }, 300);

  }, duration);

}


// ===== SICHERE INITIALISIERUNG =====

window.onload = function() {

  try {

    console.log('🚀 Starte sichere Initialisierung...');

   

    canvas = document.getElementById('fireworkCanvas');

    if (!canvas) {

      console.error('❌ Canvas-Element nicht gefunden!');

      alert('❌ FEHLER: Canvas-Element nicht gefunden! Seite neu laden (F5)');

      return;

    }

   

    ctx = canvas.getContext('2d');

    if (!ctx) {

      console.error('❌ Canvas-Kontext nicht verfügbar!');

      alert('❌ FEHLER: Canvas wird nicht unterstützt!');

      return;

    }

   

    console.log('✅ Canvas erfolgreich initialisiert');

   

    loadSavedShows();

    loadSavedEffects();

    loadEffectDatabase();

    loadIgnitionBoxPositions();

    drawCanvas();

    startAutoBackup();

    initializeAudioContext();

    setupEventListeners();

   

    console.log('✅ Initialisierung erfolgreich abgeschlossen');

   

  } catch (error) {

    console.error('❌ Kritischer Initialisierungsfehler:', error);

    alert('❌ KRITISCHER FEHLER beim Laden der Anwendung!\n\nBitte Seite neu laden (F5)');

  }

};


function setupEventListeners() {

  if (!canvas) return;

 

  // Canvas click handler mit sicherer Implementierung

  const canvasClickHandler = function(e) {

    try {

      const rect = canvas.getBoundingClientRect();

      const x = e.clientX - rect.left;

      const y = e.clientY - rect.top;

     

      // Broadcast cursor position if collaborating

      if (isCollaborating) {

        broadcastCursorPosition(x, y);

      }

     

      // Check if clicked on ignition box

      let clickedBox = null;

      Object.keys(ignitionBoxPositions).forEach(boxName => {

        const pos = ignitionBoxPositions[boxName];

        if (x >= pos.x - 25 && x <= pos.x + 25 && y >= pos.y - 15 && y <= pos.y + 15) {

          clickedBox = boxName;

        }

      });

     

      if (clickedBox) {

        // Show ignition box details

        showIgnitionBoxDetails(clickedBox);

        return;

      }

     

      // Finde nicht platzierte Effekte

      const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);

     

      if (unplacedEffects.length > 0) {

        const effectToPlace = unplacedEffects[0];

        effectToPlace.x = x;

        effectToPlace.y = y;

       

        // Update inventory

        updateInventoryForEffect(effectToPlace);

       

        updateEffectList();

        drawCanvas();

       

        // Sync with collaborators

        if (isCollaborating) {

          syncWithCollaborators();

        }

       

        // Zeige Bestätigung

        showSuccessMessage(`✅ "${escapeHtml(effectToPlace.name)}" platziert!`);

      }

    } catch (error) {

      console.error('❌ Fehler beim Canvas-Click:', error);

    }

  };

 

  addManagedEventListener(canvas, 'click', canvasClickHandler);

 

  // Mouse move for collaboration

  const mouseMoveHandler = function(e) {

    if (isCollaborating) {

      try {

        const rect = canvas.getBoundingClientRect();

        const x = e.clientX - rect.left;

        const y = e.clientY - rect.top;

        broadcastCursorPosition(x, y);

      } catch (error) {

        console.warn('⚠️ Fehler bei Cursor-Broadcast:', error);

      }

    }

  };

 

  addManagedEventListener(canvas, 'mousemove', mouseMoveHandler);

 

  // Mouse down for ignition box dragging

  const mouseDownHandler = function(e) {

    try {

      const rect = canvas.getBoundingClientRect();

      const x = e.clientX - rect.left;

      const y = e.clientY - rect.top;

     

      // Check if mouse is over an ignition box

      Object.keys(ignitionBoxPositions).forEach(boxName => {

        const pos = ignitionBoxPositions[boxName];

        if (x >= pos.x - 25 && x <= pos.x + 25 && y >= pos.y - 15 && y <= pos.y + 15) {

          draggedBox = boxName;

          isDraggingBox = true;

          dragOffset.x = x - pos.x;

          dragOffset.y = y - pos.y;

          canvas.style.cursor = 'grabbing';

          e.preventDefault();

        }

      });

    } catch (error) {

      console.error('❌ Fehler bei Mouse-Down:', error);

    }

  };

 

  // Mouse move for box dragging

  const mouseMoveBoxHandler = function(e) {

    try {

      if (isDraggingBox && draggedBox) {

        const rect = canvas.getBoundingClientRect();

        const x = e.clientX - rect.left;

        const y = e.clientY - rect.top;

       

        // Update box position

        ignitionBoxPositions[draggedBox].x = Math.max(25, Math.min(canvas.width - 25, x - dragOffset.x));

        ignitionBoxPositions[draggedBox].y = Math.max(15, Math.min(canvas.height - 15, y - dragOffset.y));

       

        drawCanvas();

        e.preventDefault();

      } else {

        // Check if hovering over a box for cursor change

        const rect = canvas.getBoundingClientRect();

        const x = e.clientX - rect.left;

        const y = e.clientY - rect.top;

       

        let hoveringBox = false;

        Object.keys(ignitionBoxPositions).forEach(boxName => {

          const pos = ignitionBoxPositions[boxName];

          if (x >= pos.x - 25 && x <= pos.x + 25 && y >= pos.y - 15 && y <= pos.y + 15) {

            hoveringBox = true;

          }

        });

       

        canvas.style.cursor = hoveringBox ? 'grab' : 'crosshair';

      }

     

      // Original collaboration cursor broadcast

      if (isCollaborating) {

        const rect = canvas.getBoundingClientRect();

        const x = e.clientX - rect.left;

        const y = e.clientY - rect.top;

        broadcastCursorPosition(x, y);

      }

    } catch (error) {

      console.warn('⚠️ Fehler bei Box-Bewegung:', error);

    }

  };

 

  // Mouse up for box dragging

  const mouseUpHandler = function(e) {

    try {

      if (isDraggingBox && draggedBox) {

        // Save new positions

        try {

          localStorage.setItem('ignitionBoxPositions', JSON.stringify(ignitionBoxPositions));

        } catch (saveError) {

          console.warn('⚠️ Konnte Box-Positionen nicht speichern:', saveError);

        }

       

        // Sync with collaborators

        if (isCollaborating) {

          syncWithCollaborators();

        }

       

        showSuccessMessage(`✅ Box ${draggedBox} verschoben!`);

      }

     

      isDraggingBox = false;

      draggedBox = null;

      canvas.style.cursor = 'crosshair';

    } catch (error) {

      console.error('❌ Fehler bei Mouse-Up:', error);

    }

  };

 

  addManagedEventListener(canvas, 'mousedown', mouseDownHandler);

  addManagedEventListener(canvas, 'mousemove', mouseMoveBoxHandler);

  addManagedEventListener(canvas, 'mouseup', mouseUpHandler);

 

  // Drag and drop for canvas

  const dragOverHandler = function(e) {

    e.preventDefault();

  };

 

  const dropHandler = function(e) {

    e.preventDefault();

    if (draggedEffect) {

      try {

        const rect = canvas.getBoundingClientRect();

        const x = e.clientX - rect.left;

        const y = e.clientY - rect.top;

       

        draggedEffect.x = x;

        draggedEffect.y = y;

        updateEffectList();

        drawCanvas();

       

        // Sync with collaborators

        if (isCollaborating) {

          syncWithCollaborators();

        }

       

        draggedEffect = null;

      } catch (error) {

        console.error('❌ Fehler beim Drop:', error);

      }

    }

  };

 

  addManagedEventListener(canvas, 'dragover', dragOverHandler);

  addManagedEventListener(canvas, 'drop', dropHandler);

}


// ===== SICHERE ZEIT-FUNKTIONEN =====

function parseTime(timeStr) {

  if (!timeStr) return 0;

  try {

    const parts = timeStr.toString().split(':');

    if (parts.length === 2) {

      const minutes = safeParseInt(parts[0]);

      const seconds = safeParseInt(parts[1]);

      return minutes * 60 + seconds;

    }

    return safeParseInt(timeStr);

  } catch (error) {

    console.warn('⚠️ Fehler beim Parsen der Zeit:', timeStr, error);

    return 0;

  }

}


function formatTime(seconds) {

  try {

    const safeSeconds = safeParseInt(seconds);

    const mins = Math.floor(safeSeconds / 60);

    const secs = safeSeconds % 60;

    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;

  } catch (error) {

    console.warn('⚠️ Fehler beim Formatieren der Zeit:', seconds, error);

    return '00:00';

  }

}


// ===== SICHERE EFFEKT-HINZUFÜGUNG =====

function addEffect() {

  console.log('🚀 SICHERE addEffect() Version 5.0 - ULTRA-SICHER');

 

  try {

    // SOFORTIGE ELEMENT-PRÜFUNG

    const nameField = document.getElementById('name');

    const timeField = document.getElementById('time');

   

    if (!nameField || !timeField) {

      console.error('❌ KRITISCH: Eingabefelder nicht gefunden!');

      alert('❌ KRITISCHER FEHLER: Eingabefelder nicht gefunden!\n\nBitte lade die Seite neu (F5)!');

      return false;

    }

   

    // WERTE ERFASSEN mit Fallback

    const name = (nameField.value || '').trim();

    const time = (timeField.value || '').trim();

   

    console.log('📝 EINGABE-CHECK:', { name: `"${name}"`, time: `"${time}"` });

   

    // SOFORTIGE VALIDIERUNG

    if (!name) {

      console.log('⚠️ Kein Name eingegeben');

      alert('❌ Bitte einen Effektnamen eingeben!');

      nameField.focus();

      nameField.style.borderColor = '#ff0000';

      nameField.style.boxShadow = '0 0 10px rgba(255,0,0,0.5)';

      setTimeout(() => {

        nameField.style.borderColor = '#555';

        nameField.style.boxShadow = 'none';

      }, 3000);

      return false;

    }

   

    if (!time) {

      console.log('⚠️ Keine Zeit eingegeben');

      alert('❌ Bitte eine Showzeit eingeben (z.B. 1:30)!');

      timeField.focus();

      timeField.style.borderColor = '#ff0000';

      timeField.style.boxShadow = '0 0 10px rgba(255,0,0,0.5)';

      setTimeout(() => {

        timeField.style.borderColor = '#555';

        timeField.style.boxShadow = 'none';

      }, 3000);

      return false;

    }

   

    console.log('✅ Validierung erfolgreich');

   

    // ALLE ANDEREN WERTE SICHER ERFASSEN

    const effectType = document.getElementById('effectType')?.value || 'rocket';

    const plannedDuration = document.getElementById('plannedDuration')?.value?.trim() || '';

    const price = safeParseFloat(document.getElementById('price')?.value);

    const barcode = document.getElementById('barcode')?.value?.trim() || '';

    const channel = document.getElementById('channel')?.value?.trim() || '';

    const receiver = document.getElementById('receiver')?.value?.trim() || '';

    const buttonKey = document.getElementById('buttonKey')?.value?.trim() || '';

    const quantity = Math.max(1, safeParseInt(document.getElementById('quantity')?.value, 1));

    const additionalInfo = document.getElementById('additionalInfo')?.value?.trim() || '';

   

    // SICHERE EINDEUTIGE ID

    const uniqueId = generateUniqueId();

    console.log('🔑 ID generiert:', uniqueId);

   

    // NEUEN EFFEKT ERSTELLEN

    const newEffect = {

      id: uniqueId,

      name: name,

      effectType: effectType,

      plannedDuration: plannedDuration,

      price: price,

      barcode: barcode,

      time: parseTime(time),

      timeStr: time,

      channel: channel,

      receiver: receiver,

      buttonKey: buttonKey,

      quantity: quantity,

      additionalInfo: additionalInfo,

      image: currentEffectImage || null,

      video: currentEffectVideo || null,

      x: null,

      y: null,

      createdAt: new Date().toISOString()

    };

   

    console.log('🎆 Effekt erstellt:', newEffect);

   

    // BACKUP VOR ÄNDERUNG

    const backup = [...effects];

    console.log('💾 Backup erstellt mit', backup.length, 'Effekten');

   

    // HINZUFÜGEN MIT SOFORTIGER PRÜFUNG

    const oldLength = effects.length;

    effects.push(newEffect);

    const newLength = effects.length;

   

    console.log('📊 Array-Länge:', oldLength, '→', newLength);

   

    if (newLength !== oldLength + 1) {

      throw new Error(`Array-Länge stimmt nicht! Erwartet: ${oldLength + 1}, Erhalten: ${newLength}`);

    }

   

    const lastEffect = effects[effects.length - 1];

    if (!lastEffect || lastEffect.id !== uniqueId) {

      throw new Error('Letzter Effekt stimmt nicht überein!');

    }

   

    console.log('✅ Effekt erfolgreich hinzugefügt!');

   

    // FORMULAR SICHER LEEREN

    try {

      nameField.value = '';

      timeField.value = '';

     

      const fieldsToReset = [

        'plannedDuration', 'price', 'barcode', 'channel',

        'receiver', 'buttonKey', 'quantity', 'additionalInfo'

      ];

     

      fieldsToReset.forEach(fieldId => {

        const field = document.getElementById(fieldId);

        if (field) field.value = '';

      });

     

      clearImage();

      clearVideo();

      console.log('🧹 Formular geleert');

    } catch (clearError) {

      console.warn('⚠️ Formular-Clearing-Fehler (nicht kritisch):', clearError);

    }

   

    // UI SICHER AKTUALISIEREN

    try {

      updateEffectList();

      updateCostCalculation();

      drawCanvas();

      checkInventoryWarnings();

      console.log('🔄 UI aktualisiert');

    } catch (uiError) {

      console.error('❌ UI-Update-Fehler:', uiError);

      alert('⚠️ Effekt gespeichert, aber UI-Update fehlgeschlagen. Seite neu laden empfohlen.');

    }

   

    // KOLLABORATION

    if (isCollaborating) {

      try {

        syncWithCollaborators();

      } catch (syncError) {

        console.warn('⚠️ Kollaborations-Sync fehlgeschlagen:', syncError);

      }

    }

   

    // ERFOLGS-NACHRICHT

    console.log(`🎉 ERFOLG: "${name}" gespeichert! Show hat jetzt ${effects.length} Effekte`);

   

    // VISUELLE BESTÄTIGUNG

    showSuccessMessage(`✅ "${escapeHtml(name)}" erfolgreich gespeichert! Show hat jetzt ${effects.length} Effekte`);

   

    // BUTTON-FEEDBACK

    const saveButton = document.querySelector('button[onclick="addEffect()"]');

    if (saveButton) {

      const originalText = saveButton.textContent;

      const originalBg = saveButton.style.background;

     

      saveButton.textContent = '✅ Gespeichert!';

      saveButton.style.background = '#4caf50';

      saveButton.style.transform = 'scale(1.05)';

      saveButton.style.transition = 'all 0.2s';

     

      setTimeout(() => {

        saveButton.textContent = originalText;

        saveButton.style.background = originalBg;

        saveButton.style.transform = 'scale(1)';

      }, 2000);

    }

   

    console.log('🎉 addEffect() KOMPLETT ERFOLGREICH!');

    return true;

   

  } catch (error) {

    console.error('❌ KRITISCHER FEHLER in addEffect():', error);

   

    // Rollback bei Fehler

    try {

      if (backup && Array.isArray(backup)) {

        effects.length = 0;

        effects.push(...backup);

        console.log('🔄 Backup wiederhergestellt');

      }

    } catch (rollbackError) {

      console.error('❌ Rollback fehlgeschlagen:', rollbackError);

    }

   

    alert('❌ Fehler beim Speichern des Effekts!\n\nFehler: ' + error.message + '\n\nBackup wurde wiederhergestellt.');

    return false;

  }

}


// ===== SICHERE EFFEKT-LISTE =====

function updateEffectList() {

  try {

    const list = document.getElementById('effectList');

    if (!list) {

      console.error('❌ EffectList-Element nicht gefunden!');

      return;

    }

   

    list.innerHTML = '<h3>Effekte in der Show</h3>';

   

    if (!Array.isArray(effects)) {

      console.error('❌ Effects ist kein Array!');

      effects = [];

      return;

    }

   

    effects.sort((a, b) => (a.time || 0) - (b.time || 0));

   

    effects.forEach(effect => {

      if (!effect || !effect.id) {

        console.warn('⚠️ Ungültiger Effekt gefunden:', effect);

        return;

      }

     

      try {

        const div = document.createElement('div');

        div.className = 'effect-item';

       

        // Check inventory status

        const dbEffect = effectDatabase.find(e =>

          (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode)

        );

       

        if (dbEffect && typeof dbEffect.stockQuantity === 'number') {

          if (dbEffect.stockQuantity === 0) {

            div.classList.add('out-of-stock');

          } else if (dbEffect.stockQuantity < (effect.quantity || 1)) {

            div.classList.add('low-stock');

          }

        }

       

        div.draggable = true;

       

        // Sichere HTML-Erstellung

        const safeName = escapeHtml(effect.name || 'Unbenannt');

        const safeTimeStr = escapeHtml(effect.timeStr || '0:00');

        const safeEffectType = escapeHtml(effect.effectType || 'rocket');

        const safeChannel = escapeHtml(effect.channel || 'Nicht gesetzt');

        const safeButtonKey = escapeHtml(effect.buttonKey || 'Nicht gesetzt');

        const safePrice = (effect.price && effect.price > 0) ? safeParseFloat(effect.price).toFixed(2) : '0.00';

        const safeQuantity = Math.max(1, safeParseInt(effect.quantity, 1));

       

        const positionText = (effect.x !== null && effect.y !== null)

          ? `X:${Math.round(effect.x)}, Y:${Math.round(effect.y)}`

          : 'Nicht platziert';

       

        const stockText = (dbEffect && typeof dbEffect.stockQuantity === 'number')

          ? `<br>Lager: ${dbEffect.stockQuantity}x`

          : '';

       

        const ignitionText = (effect.ignitionBox && effect.ignitionChannel)

          ? `<br><span style="color: #00ffff;">📡 Box ${escapeHtml(effect.ignitionBox)}-${escapeHtml(effect.ignitionChannel)}</span>`

          : '';

       

        div.innerHTML = `

          <div style="display: flex; align-items: center;">

            ${effect.image ? `<img src="${effect.image}" class="effect-image" alt="Effekt" onerror="this.style.display='none';">` : ''}

            ${effect.video ? `<video src="${effect.video}" class="effect-video" muted onerror="this.style.display='none';"></video>` : ''}

            <div>

              <strong>${safeName}</strong><br>

              Zeit: ${safeTimeStr} | Typ: ${safeEffectType}<br>

              Kanal: ${safeChannel} | Taste: ${safeButtonKey}<br>

              Preis: ${safePrice}€ | Anzahl: ${safeQuantity}<br>

              Position: ${positionText}${stockText}${ignitionText}

            </div>

          </div>

          <div style="display: flex; gap: 5px;">

            <button onclick="selectEffectForIgnition('${effect.id}')" style="background: #ff9800; color: white; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;" title="Zu Zündanlage zuweisen">📡</button>

            <button class="effect-edit" onclick="editEffect('${effect.id}')" style="background: #2196f3; color: white; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">✏️</button>

            <button class="effect-delete" onclick="deleteEffect('${effect.id}')">×</button>

          </div>

        `;

       

        // Add drag handlers

        div.addEventListener('dragstart', function(e) {

          draggedEffect = effect;

          div.classList.add('dragging');

        });

       

        div.addEventListener('dragend', function(e) {

          div.classList.remove('dragging');

        });

       

        list.appendChild(div);

       

      } catch (itemError) {

        console.error('❌ Fehler beim Erstellen des Effekt-Items:', itemError, effect);

      }

    });

   

  } catch (error) {

    console.error('❌ Fehler beim Aktualisieren der Effekt-Liste:', error);

  }

}


// ===== SICHERE KOSTEN-BERECHNUNG =====

function updateCostCalculation() {

  try {

    let totalCost = 0;

    let totalEffects = 0;

   

    if (Array.isArray(effects)) {

      effects.forEach(effect => {

        if (effect && typeof effect === 'object') {

          const price = safeParseFloat(effect.price);

          const quantity = Math.max(1, safeParseInt(effect.quantity, 1));

          totalCost += price * quantity;

          totalEffects += quantity;

        }

      });

    }

   

    const totalCostElement = document.getElementById('totalCost');

    const effectCountElement = document.getElementById('effectCount');

   

    if (totalCostElement) {

      totalCostElement.textContent = `Gesamtkosten: ${totalCost.toFixed(2)} €`;

    }

   

    if (effectCountElement) {

      effectCountElement.textContent = `Anzahl Effekte: ${totalEffects}`;

    }

   

    updateEffectOverview();

   

  } catch (error) {

    console.error('❌ Fehler bei Kostenberechnung:', error);

  }

}


// ===== SICHERE ÜBERSICHT =====

function updateEffectOverview() {

  try {

    const overviewDiv = document.getElementById('overviewTable');

    if (!overviewDiv) return;

   

    if (!Array.isArray(effects) || effects.length === 0) {

      overviewDiv.innerHTML = '<p style="color: #666; font-style: italic;">Keine Effekte in der Show</p>';

      return;

    }

   

    const sortedEffects = [...effects].sort((a, b) => (a.time || 0) - (b.time || 0));

   

    let html = `

      <table class="overview-table">

        <thead>

          <tr>

            <th>Zeit</th>

            <th>Effekt</th>

            <th>Typ</th>

            <th>Dauer</th>

            <th>Kanal</th>

            <th>Taste</th>

            <th>Empfänger</th>

            <th>Preis</th>

            <th>Anzahl</th>

            <th>Lager</th>

          </tr>

        </thead>

        <tbody>

    `;

   

    sortedEffects.forEach(effect => {

      if (!effect) return;

     

      try {

        const dbEffect = effectDatabase.find(e =>

          (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode)

        );

        const stockInfo = (dbEffect && typeof dbEffect.stockQuantity === 'number') ? dbEffect.stockQuantity : '-';

       

        const safeName = escapeHtml(effect.name || 'Unbenannt');

        const safeTimeStr = escapeHtml(effect.timeStr || '0:00');

        const safeEffectType = escapeHtml(effect.effectType || 'rocket');

        const safeDuration = escapeHtml(effect.plannedDuration || '-');

        const safeChannel = escapeHtml(effect.channel || '-');

        const safeButtonKey = escapeHtml(effect.buttonKey || '-');

        const safeReceiver = escapeHtml(effect.receiver || '-');

        const safePrice = (effect.price && effect.price > 0) ? safeParseFloat(effect.price).toFixed(2) + '€' : '-';

        const safeQuantity = Math.max(1, safeParseInt(effect.quantity, 1));

       

        const stockColor = stockInfo === 0 ? '#f44336' : (stockInfo <= 5 && stockInfo !== '-' ? '#ff9800' : '#4caf50');

       

        html += `

          <tr>

            <td class="time-cell">${safeTimeStr}</td>

            <td><strong>${safeName}</strong></td>

            <td>${safeEffectType}</td>

            <td>${safeDuration}</td>

            <td class="channel-cell">${safeChannel}</td>

            <td class="button-cell">${safeButtonKey}</td>

            <td>${safeReceiver}</td>

            <td>${safePrice}</td>

            <td>${safeQuantity}</td>

            <td style="color: ${stockColor}">${stockInfo}</td>

          </tr>

        `;

      } catch (rowError) {

        console.error('❌ Fehler beim Erstellen der Tabellenzeile:', rowError, effect);

      }

    });

   

    html += '</tbody></table>';

    overviewDiv.innerHTML = html;

   

  } catch (error) {

    console.error('❌ Fehler bei Effekt-Übersicht:', error);

  }

}


// ===== SICHERE DATENBANK-FUNKTIONEN =====

function loadIgnitionBoxPositions() {

  try {

    const saved = localStorage.getItem('ignitionBoxPositions');

    if (saved) {

      const positions = JSON.parse(saved);

      if (positions && typeof positions === 'object') {

        // Merge with default positions to ensure all boxes exist

        Object.keys(ignitionBoxPositions).forEach(boxName => {

          if (positions[boxName] && typeof positions[boxName].x === 'number' && typeof positions[boxName].y === 'number') {

            ignitionBoxPositions[boxName] = positions[boxName];

          }

        });

        console.log('✅ Zündbox-Positionen geladen');

      }

    }

  } catch (error) {

    console.error('❌ Fehler beim Laden der Box-Positionen:', error);

  }

}


function loadEffectDatabase() {

  console.log('🔧 Lade Effekt-Datenbank sicher...');

 

  try {

    const saved = localStorage.getItem('effectDatabase');

    if (saved) {

      const parsedDatabase = JSON.parse(saved);

      console.log('✅ Datenbank aus LocalStorage geladen:', parsedDatabase.length, 'Effekte');

     

      if (!Array.isArray(parsedDatabase)) {

        console.error('❌ Datenbank ist kein Array, erstelle leere Datenbank...');

        effectDatabase = [];

        localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));

        updateDatabaseList();

        return;

      }

     

      effectDatabase = parsedDatabase;

      console.log('✅ Datenbank erfolgreich geladen, aktualisiere Dropdown...');

      updateDatabaseList();

      checkInventoryWarnings();

     

      if (effectDatabase.length === 0) {

        console.log('ℹ️ Datenbank ist leer - das ist OK!');

      } else {

        console.log(`✅ ${effectDatabase.length} Effekte erfolgreich geladen`);

      }

     

    } else {

      console.log('🔧 Keine Datenbank gefunden, erstelle leere Datenbank...');

      effectDatabase = [];

      localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));

      updateDatabaseList();

    }

  } catch (error) {

    console.error('❌ Fehler beim Laden der Datenbank:', error);

    effectDatabase = [];

    localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));

    updateDatabaseList();

  }

}


function updateDatabaseList() {

  console.log('🔧 Starte sichere Dropdown-Aktualisierung...');

 

  try {

    const select = document.getElementById('effectDatabase');

   

    if (!select) {

      console.error('❌ Dropdown-Element "effectDatabase" nicht gefunden!');

      return;

    }

   

    console.log(`📊 Aktualisiere Dropdown mit ${effectDatabase.length} Effekten`);

   

    select.innerHTML = '';

   

    const defaultOption = document.createElement('option');

    defaultOption.value = '';

    defaultOption.textContent = `📊 Effekt-Datenbank (${effectDatabase.length} Effekte)`;

    select.appendChild(defaultOption);

   

    if (effectDatabase.length > 100) {

      console.log('⚡ Verwende Performance-Modus für große Datenbank');

     

      const searchButton = document.getElementById('searchButton');

      if (searchButton) {

        searchButton.style.display = 'inline-block';

      }

     

      const maxDisplay = Math.min(20, effectDatabase.length);

     

      for (let i = 0; i < maxDisplay; i++) {

        const effect = effectDatabase[i];

        if (!effect) continue;

       

        const option = document.createElement('option');

        option.value = i.toString();

       

        const price = (effect.price && effect.price > 0) ? ` ${safeParseFloat(effect.price).toFixed(2)}€` : '';

        const stock = (typeof effect.stockQuantity === 'number') ? ` (${effect.stockQuantity}x)` : '';

        const safeName = escapeHtml(effect.name || 'Unbenannt');

        const shortName = safeName.length > 20 ? safeName.substring(0, 20) + '...' : safeName;

       

        option.textContent = `${shortName}${price}${stock}`;

        select.appendChild(option);

      }

     

      if (effectDatabase.length > maxDisplay) {

        const moreOption = document.createElement('option');

        moreOption.value = 'search';

        moreOption.textContent = `... ${effectDatabase.length - maxDisplay} weitere → Suchbutton nutzen`;

        moreOption.disabled = true;

        select.appendChild(moreOption);

      }

     

    } else {

      const searchButton = document.getElementById('searchButton');

      if (searchButton) {

        searchButton.style.display = 'none';

      }

     

      effectDatabase.forEach((effect, index) => {

        if (!effect) return;

       

        try {

          const option = document.createElement('option');

          option.value = index.toString();

         

          const price = (effect.price && effect.price > 0) ? `${safeParseFloat(effect.price).toFixed(2)}€` : '';

          const duration = escapeHtml(effect.duration || effect.plannedDuration || '');

          const type = escapeHtml(effect.effectType || effect.type || '');

          const hasImage = effect.image ? '📸 ' : '';

          const hasVideo = effect.video ? '🎬 ' : '';

          const stock = (typeof effect.stockQuantity === 'number') ? ` (${effect.stockQuantity}x)` : '';

          const safeName = escapeHtml(effect.name || 'Unbenannt');

         

          option.textContent = `${hasImage}${hasVideo}${safeName} ${price ? '- ' + price : ''} ${duration ? '- ' + duration : ''} ${type ? '- ' + type : ''}${stock}`;

         

          // Add visual indicator for low stock

          if (typeof effect.stockQuantity === 'number') {

            if (effect.stockQuantity === 0) {

              option.style.color = '#f44336';

              option.style.fontWeight = 'bold';

            } else if (effect.stockQuantity <= 5) {

              option.style.color = '#ff9800';

            }

          }

         

          select.appendChild(option);

        } catch (optionError) {

          console.error('❌ Fehler beim Erstellen der Option:', optionError, effect);

        }

      });

    }

   

    console.log('✅ Dropdown sicher aktualisiert!');

   

  } catch (error) {

    console.error('❌ Fehler beim Aktualisieren der Dropdown-Liste:', error);

  }

}


function selectFromDatabase() {

  try {

    const select = document.getElementById('effectDatabase');

    const selectedValue = select.value;

   

    console.log('🔍 Sichere Datenbank-Auswahl gestartet:', {

      selectedValue: selectedValue,

      databaseLength: effectDatabase.length

    });

   

    if (!selectedValue || selectedValue === '') {

      console.log('ℹ️ Keine Auswahl getroffen');

      return;

    }

   

    const index = safeParseInt(selectedValue, -1);

    console.log('🔢 Index berechnet:', index);

   

    if (index < 0 || index >= effectDatabase.length) {

      console.error('❌ Ungültiger Index:', {

        originalValue: selectedValue,

        parsedIndex: index,

        databaseLength: effectDatabase.length

      });

      alert(`❌ Fehler: Ungültiger Index ${index} für Datenbank mit ${effectDatabase.length} Einträgen!`);

      return;

    }

   

    const effect = effectDatabase[index];

    console.log('📋 Effekt gefunden:', effect);

   

    if (!effect) {

      console.error('❌ Effekt nicht gefunden bei Index:', index);

      alert('❌ Effekt nicht gefunden!');

      return;

    }

   

    const fields = {

      name: document.getElementById('name'),

      effectType: document.getElementById('effectType'),

      plannedDuration: document.getElementById('plannedDuration'),

      price: document.getElementById('price'),

      barcode: document.getElementById('barcode'),

      stockQuantity: document.getElementById('stockQuantity')

    };

   

    for (const [fieldName, field] of Object.entries(fields)) {

      if (!field) {

        console.error(`❌ Feld ${fieldName} nicht gefunden!`);

        alert(`❌ Eingabefeld ${fieldName} nicht gefunden!`);

        return;

      }

    }

   

    fields.name.value = escapeHtml(effect.name || '');

    fields.effectType.value = effect.effectType || effect.type || 'rocket';

    fields.plannedDuration.value = escapeHtml(effect.duration || effect.plannedDuration || '');

    fields.price.value = (effect.price && effect.price > 0) ? safeParseFloat(effect.price).toFixed(2) : '';

    fields.barcode.value = escapeHtml(effect.barcode || '');

    fields.stockQuantity.value = (typeof effect.stockQuantity === 'number') ? effect.stockQuantity.toString() : '';

   

    console.log('✅ Felder sicher gefüllt');

   

    // Load image if available

    if (effect.image) {

      currentEffectImage = effect.image;

      const previewDiv = document.getElementById('imagePreview');

      if (previewDiv) {

        previewDiv.innerHTML = `<img src="${effect.image}" class="image-preview" alt="Effekt Bild" onerror="this.style.display='none';">`;

        console.log('📸 Bild geladen');

      }

    } else {

      clearImage();

    }

   

    // Load video if available

    if (effect.video) {

      currentEffectVideo = effect.video;

      const previewDiv = document.getElementById('videoPreview');

      if (previewDiv) {

        previewDiv.innerHTML = `

          <video class="video-preview" controls muted onerror="this.style.display='none';">

            <source src="${effect.video}" type="video/mp4">

            Ihr Browser unterstützt keine Videos.

          </video>

        `;

        console.log('🎬 Video geladen');

      }

    } else {

      clearVideo();

    }

   

    // Visual feedback

    fields.name.style.background = '#2d5a2d';

    fields.name.style.borderColor = '#4caf50';

    fields.name.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.5)';

   

    setTimeout(() => {

      fields.name.style.background = '#222';

      fields.name.style.borderColor = '#555';

      fields.name.style.boxShadow = 'none';

    }, 2000);

   

    // Success message

    const imageText = effect.image ? ' 📸' : '';

    const videoText = effect.video ? ' 🎬' : '';

    const stockText = (typeof effect.stockQuantity === 'number') ? ` (${effect.stockQuantity}x verfügbar)` : '';

    const priceText = (effect.price && effect.price > 0) ? ` - ${safeParseFloat(effect.price).toFixed(2)}€` : '';

   

    console.log(`✅ Effekt "${effect.name}"${imageText}${videoText}${stockText}${priceText} erfolgreich geladen!`);

   

    showSuccessMessage(`✅ "${escapeHtml(effect.name || 'Effekt')}" aus Datenbank geladen!${imageText}${videoText}${stockText}`);

   

  } catch (error) {

    console.error('❌ Fehler beim Laden des Effekts:', error);

    alert('❌ Fehler beim Laden des Effekts: ' + error.message);

  }

}


// ===== WEITERE SICHERE FUNKTIONEN =====


// Video handling functions

function previewVideo() {

  try {

    const fileInput = document.getElementById('effectVideo');

    const file = fileInput?.files?.[0];

    const previewDiv = document.getElementById('videoPreview');

   

    if (!previewDiv) return;

   

    if (file) {

      const url = URL.createObjectURL(file);

      const reader = new FileReader();

      reader.onload = function(e) {

        currentEffectVideo = e.target.result;

        previewDiv.innerHTML = `

          <video class="video-preview" controls muted onerror="this.style.display='none';">

            <source src="${url}" type="${file.type}">

            Ihr Browser unterstützt keine Videos.

          </video>

        `;

      };

      reader.readAsDataURL(file);

    } else {

      clearVideo();

    }

  } catch (error) {

    console.error('❌ Fehler bei Video-Vorschau:', error);

  }

}


function clearVideo() {

  try {

    currentEffectVideo = null;

    const previewDiv = document.getElementById('videoPreview');

    const fileInput = document.getElementById('effectVideo');

   

    if (previewDiv) previewDiv.innerHTML = '';

    if (fileInput) fileInput.value = '';

  } catch (error) {

    console.error('❌ Fehler beim Video-Löschen:', error);

  }

}


// Image handling functions

function previewImage() {

  try {

    const fileInput = document.getElementById('effectImage');

    const file = fileInput?.files?.[0];

    const previewDiv = document.getElementById('imagePreview');

   

    if (!previewDiv) return;

   

    if (file) {

      const reader = new FileReader();

      reader.onload = function(e) {

        currentEffectImage = e.target.result;

        previewDiv.innerHTML = `<img src="${currentEffectImage}" class="image-preview" alt="Effekt Vorschau" onerror="this.style.display='none';">`;

      };

      reader.readAsDataURL(file);

    } else {

      clearImage();

    }

  } catch (error) {

    console.error('❌ Fehler bei Bild-Vorschau:', error);

  }

}


function clearImage() {

  try {

    currentEffectImage = null;

    const previewDiv = document.getElementById('imagePreview');

    const fileInput = document.getElementById('effectImage');

   

    if (previewDiv) previewDiv.innerHTML = '';

    if (fileInput) fileInput.value = '';

  } catch (error) {

    console.error('❌ Fehler beim Bild-Löschen:', error);

  }

}


// ===== SICHERE CANVAS-FUNKTIONEN =====

function drawCanvas() {

  try {

    if (!ctx || !canvas) {

      console.warn('⚠️ Canvas oder Kontext nicht verfügbar');

      return;

    }

   

    ctx.clearRect(0, 0, canvas.width, canvas.height);

   

    // Draw grid

    ctx.strokeStyle = '#333';

    ctx.lineWidth = 1;

    for (let x = 0; x <= canvas.width; x += 50) {

      ctx.beginPath();

      ctx.moveTo(x, 0);

      ctx.lineTo(x, canvas.height);

      ctx.stroke();

    }

    for (let y = 0; y <= canvas.height; y += 50) {

      ctx.beginPath();

      ctx.moveTo(0, y);

      ctx.lineTo(canvas.width, y);

      ctx.stroke();

    }

   

    // Draw ignition boxes

    drawIgnitionBoxes();

   

    // Draw beat markers if available

    if (Array.isArray(beatTimes) && beatTimes.length > 0) {

      ctx.strokeStyle = '#ff9800';

      ctx.lineWidth = 2;

      const maxMarkers = Math.min(10, beatTimes.length);

      for (let i = 0; i < maxMarkers; i++) {

        const x = (i / maxMarkers) * canvas.width;

        ctx.beginPath();

        ctx.moveTo(x, 0);

        ctx.lineTo(x, canvas.height);

        ctx.stroke();

      }

    }

   

    // Draw collaboration cursors

    if (isCollaborating) {

      drawCollaborationCursors();

    }

   

    // Draw effects

    if (Array.isArray(effects)) {

      effects.forEach(effect => {

        if (!effect || typeof effect.x !== 'number' || typeof effect.y !== 'number') return;

       

        try {

          const colors = {

            rocket: '#ff4444',

            fountain: '#44ff44',

            battery: '#4444ff'

          };

         

          // Check inventory status for color modification

          const dbEffect = effectDatabase.find(e =>

            (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode)

          );

         

          let effectColor = colors[effect.effectType] || '#ffffff';

         

          if (dbEffect && typeof dbEffect.stockQuantity === 'number') {

            if (dbEffect.stockQuantity === 0) {

              effectColor = '#666666'; // Gray for out of stock

            } else if (dbEffect.stockQuantity < (effect.quantity || 1)) {

              effectColor = '#ff9800'; // Orange for low stock

            }

          }

         

          // Draw effect circle

          ctx.fillStyle = effectColor;

          ctx.beginPath();

          ctx.arc(effect.x, effect.y, 8, 0, 2 * Math.PI);

          ctx.fill();

         

          // Draw media icons

          if (effect.image) {

            ctx.fillStyle = '#ffff00';

            ctx.font = '16px Arial';

            ctx.fillText('📸', effect.x - 8, effect.y - 12);

          }

         

          if (effect.video) {

            ctx.fillStyle = '#ff00ff';

            ctx.font = '16px Arial';

            ctx.fillText('🎬', effect.x + 8, effect.y - 12);

          }

         

          ctx.fillStyle = '#ffffff';

          ctx.font = '12px Arial';

          ctx.fillText(escapeHtml(effect.name || 'Effekt'), effect.x + 12, effect.y + 4);

          ctx.fillText(escapeHtml(effect.timeStr || '0:00'), effect.x + 12, effect.y + 16);

         

          if (effect.ignitionBox && effect.ignitionChannel) {

            ctx.fillStyle = '#00ffff';

            ctx.fillText(`${escapeHtml(effect.ignitionBox)}${escapeHtml(effect.ignitionChannel)}`, effect.x + 12, effect.y + 28);

          } else if (effect.channel && effect.buttonKey) {

            ctx.fillStyle = '#00ffff';

            ctx.fillText(`K${escapeHtml(effect.channel)}-T${escapeHtml(effect.buttonKey)}`, effect.x + 12, effect.y + 28);

          }

         

          if (effect.price && effect.price > 0) {

            ctx.fillStyle = '#90ee90';

            ctx.fillText(`${safeParseFloat(effect.price).toFixed(2)}€`, effect.x + 12, effect.y + 40);

          }

         

          // Show inventory warning

          if (dbEffect && typeof dbEffect.stockQuantity === 'number' && dbEffect.stockQuantity < (effect.quantity || 1)) {

            ctx.fillStyle = '#ff0000';

            ctx.font = 'bold 10px Arial';

            ctx.fillText('⚠️', effect.x - 15, effect.y - 15);

          }

        } catch (effectError) {

          console.error('❌ Fehler beim Zeichnen des Effekts:', effectError, effect);

        }

      });

    }

   

    // Show unplaced effects info

    const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);

    if (unplacedEffects.length > 0) {

      ctx.fillStyle = '#ffff00';

      ctx.font = 'bold 16px Arial';

      ctx.fillText(`${unplacedEffects.length} Effekt(e) noch nicht platziert`, 20, 30);

      ctx.font = '14px Arial';

      ctx.fillText('Klicke auf das Abbrennfeld um sie zu platzieren', 20, 50);

     

      if (unplacedEffects[0]) {

        ctx.fillStyle = '#ff8800';

        ctx.fillText(`Nächster: "${escapeHtml(unplacedEffects[0].name || 'Effekt')}"`, 20, 70);

      }

    }

   

    // Show beat sync info

    if (Array.isArray(beatTimes) && beatTimes.length > 0) {

      ctx.fillStyle = '#ff9800';

      ctx.font = '12px Arial';

      ctx.fillText(`🎵 ${beatTimes.length} Beats | ${bpm} BPM`, canvas.width - 150, 20);

    }

   

    // Show collaboration info

    if (isCollaborating) {

      ctx.fillStyle = '#2196f3';

      ctx.font = '12px Arial';

      ctx.fillText('👥 Team-Modus aktiv', canvas.width - 150, canvas.height - 10);

    }

   

  } catch (error) {

    console.error('❌ Fehler beim Zeichnen des Canvas:', error);

  }

}


function drawIgnitionBoxes() {

  try {

    // Draw ignition boxes at their current positions (moveable)

    Object.keys(ignitionBoxPositions).forEach(boxName => {

      const pos = ignitionBoxPositions[boxName];

      const box = ignitionBoxes[boxName] || {};

      const assignedChannels = Object.keys(box).length;

     

      // Box background (with drag highlight)

      const isDragging = (isDraggingBox && draggedBox === boxName);

      let bgColor = assignedChannels > 0 ? '#1a4d1a' : '#2a2a2a';

      if (isDragging) {

        bgColor = '#4a4a00'; // Yellow tint when dragging

      }

     

      ctx.fillStyle = bgColor;

      ctx.fillRect(pos.x - 25, pos.y - 15, 50, 30);

     

      // Box border (with drag highlight)

      let borderColor = assignedChannels > 0 ? '#4caf50' : '#666';

      if (isDragging) {

        borderColor = '#ffff00'; // Yellow border when dragging

      }

     

      ctx.strokeStyle = borderColor;

      ctx.lineWidth = isDragging ? 3 : 2;

      ctx.strokeRect(pos.x - 25, pos.y - 15, 50, 30);

     

      // Drag handle indicator

      if (!isDragging) {

        ctx.fillStyle = '#888';

        ctx.font = '8px Arial';

        ctx.textAlign = 'right';

        ctx.fillText('⋮⋮', pos.x + 22, pos.y - 8);

      }

     

      // Box label

      ctx.fillStyle = '#ffffff';

      ctx.font = 'bold 14px Arial';

      ctx.textAlign = 'center';

      ctx.fillText(`📡${boxName}`, pos.x, pos.y - 2);

     

      // Channel count

      ctx.font = '10px Arial';

      ctx.fillStyle = assignedChannels > 0 ? '#4caf50' : '#999';

      ctx.fillText(`${assignedChannels}/32`, pos.x, pos.y + 10);

     

      // Status indicator

      if (assignedChannels > 0) {

        ctx.fillStyle = '#4caf50';

        ctx.beginPath();

        ctx.arc(pos.x + 20, pos.y - 10, 3, 0, 2 * Math.PI);

        ctx.fill();

      }

     

      // Show connected effects on hover (simplified - always show if assigned)

      if (assignedChannels > 0) {

        ctx.font = '8px Arial';

        ctx.fillStyle = '#ffff00';

        let yOffset = 25;

       

        // Show first few assigned channels

        const sortedChannels = Object.keys(box).sort((a, b) => parseInt(a) - parseInt(b)).slice(0, 3);

        sortedChannels.forEach(channel => {

          const effect = box[channel];

          if (effect) {

            ctx.fillText(`${channel}:${escapeHtml(effect.name.substring(0, 8))}`, pos.x, pos.y + yOffset);

            yOffset += 10;

          }

        });

       

        if (assignedChannels > 3) {

          ctx.fillText(`+${assignedChannels - 3} mehr`, pos.x, pos.y + yOffset);

        }

      }

    });

   

    ctx.textAlign = 'left'; // Reset text alignment

   

  } catch (error) {

    console.error('❌ Fehler beim Zeichnen der Zündboxen:', error);

  }

}


function drawCollaborationCursors() {

  try {

    // In a real implementation, this would draw other users' cursors

    // For now, we'll just show a placeholder

    if (Array.isArray(collaborators) && collaborators.length > 0) {

      collaborators.forEach((collaborator, index) => {

        if (!collaborator || typeof collaborator.x !== 'number' || typeof collaborator.y !== 'number') return;

       

        ctx.fillStyle = `hsl(${index * 60}, 70%, 50%)`;

        ctx.beginPath();

        ctx.arc(collaborator.x, collaborator.y, 5, 0, 2 * Math.PI);

        ctx.fill();

       

        ctx.fillStyle = '#ffffff';

        ctx.font = '10px Arial';

        ctx.fillText(escapeHtml(collaborator.name || 'User'), collaborator.x + 10, collaborator.y - 10);

      });

    }

  } catch (error) {

    console.error('❌ Fehler beim Zeichnen der Kollaborations-Cursor:', error);

  }

}


// ===== PLATZHALTER FÜR WEITERE FUNKTIONEN =====

// Hier würden alle anderen Funktionen in ähnlicher Weise korrigiert werden...

// Aus Platzgründen zeige ich nur die wichtigsten korrigierten Funktionen


// Sichere Zündanlagen-Funktionen

function selectEffectForIgnition(effectId) {

  try {

    selectedEffect = effects.find(e => e && e.id === effectId);

    if (selectedEffect) {

      updateCurrentSelection();

     

      // Scroll zur Zündanlagen-Sektion

      const ignitionBox = document.querySelector('#ignitionBox');

      if (ignitionBox) {

        ignitionBox.scrollIntoView({ behavior: 'smooth' });

       

        // Highlight der Zündanlagen-Sektion

        const section = ignitionBox.closest('div[style*="background: #1a1a2e"]');

        if (section) {

          section.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.5)';

          setTimeout(() => {

            section.style.boxShadow = 'none';

          }, 3000);

        }

      }

    }

  } catch (error) {

    console.error('❌ Fehler bei Effekt-Auswahl für Zündanlage:', error);

  }

}


function updateCurrentSelection() {

  try {

    const selectionDiv = document.getElementById('currentSelection');

    if (!selectionDiv) return;

   

    if (selectedEffect) {

      const currentAssignment = (selectedEffect.ignitionBox && selectedEffect.ignitionChannel)

        ? `📡 Aktuell: Box ${escapeHtml(selectedEffect.ignitionBox)}-${escapeHtml(selectedEffect.ignitionChannel)}`

        : '📡 Noch nicht zugewiesen';

     

      selectionDiv.innerHTML = `

        <div style="color: #4caf50;">

          <strong>🎆 ${escapeHtml(selectedEffect.name || 'Effekt')}</strong><br>

          <span style="color: #ccc;">Zeit: ${escapeHtml(selectedEffect.timeStr || '0:00')}</span><br>

          <span style="color: #ccc;">Typ: ${escapeHtml(selectedEffect.effectType || 'rocket')}</span><br>

          <span style="color: #ff9800;">${currentAssignment}</span>

        </div>

      `;

    } else {

      selectionDiv.innerHTML = '<p style="color: #666; font-style: italic;">Kein Effekt ausgewählt</p>';

    }

  } catch (error) {

    console.error('❌ Fehler bei Auswahl-Update:', error);

  }

}


// Sichere Lösch-Funktion

function deleteEffect(id) {

  try {

    if (confirm('Effekt wirklich löschen?')) {

      const oldLength = effects.length;

      effects = effects.filter(e => e && e.id !== id);

     

      if (effects.length === oldLength - 1) {

        updateEffectList();

        updateCostCalculation();

        drawCanvas();

        checkInventoryWarnings();

       

        // Sync with collaborators

        if (isCollaborating) {

          syncWithCollaborators();

        }

       

        showSuccessMessage('✅ Effekt gelöscht!');

      } else {

        console.error('❌ Effekt konnte nicht gelöscht werden');

        alert('❌ Fehler beim Löschen des Effekts!');

      }

    }

  } catch (error) {

    console.error('❌ Fehler beim Löschen des Effekts:', error);

    alert('❌ Fehler beim Löschen: ' + error.message);

  }

}


// ===== ZÜNDANLAGEN-FUNKTIONEN =====

function selectIgnitionBox() {

  try {

    const boxSelect = document.getElementById('ignitionBox');

    const channelInput = document.getElementById('selectedChannel');

   

    if (!boxSelect || !channelInput) return;

   

    const selectedBox = boxSelect.value;

   

    if (selectedBox) {

      // Auto-suggest next free channel

      const usedChannels = Object.keys(ignitionBoxes[selectedBox] || {}).map(ch => parseInt(ch));

      let nextFreeChannel = 1;

     

      while (usedChannels.includes(nextFreeChannel) && nextFreeChannel <= 32) {

        nextFreeChannel++;

      }

     

      if (nextFreeChannel <= 32) {

        channelInput.value = nextFreeChannel;

        channelInput.style.background = '#2d5a2d';

        channelInput.style.borderColor = '#4caf50';

       

        setTimeout(() => {

          channelInput.style.background = '#333';

          channelInput.style.borderColor = '#555';

        }, 1500);

      }

    }

  } catch (error) {

    console.error('❌ Fehler bei Box-Auswahl:', error);

  }

}


function assignToBox() {

  try {

    if (!selectedEffect) {

      alert('❌ Bitte zuerst einen Effekt auswählen!\n\nKlicke auf das 📡-Symbol neben einem Effekt.');

      return;

    }

   

    const boxSelect = document.getElementById('ignitionBox');

    const channelInput = document.getElementById('selectedChannel');

   

    if (!boxSelect || !channelInput) {

      alert('❌ Eingabefelder nicht gefunden!');

      return;

    }

   

    const selectedBox = boxSelect.value;

    const selectedChannel = parseInt(channelInput.value);

   

    if (!selectedBox) {

      alert('❌ Bitte eine Zündbox auswählen!');

      boxSelect.focus();

      return;

    }

   

    if (!selectedChannel || selectedChannel < 1 || selectedChannel > 32) {

      alert('❌ Bitte einen gültigen Kanal (1-32) eingeben!');

      channelInput.focus();

      return;

    }

   

    // Check if channel is already occupied

    if (ignitionBoxes[selectedBox] && ignitionBoxes[selectedBox][selectedChannel]) {

      const occupiedEffect = ignitionBoxes[selectedBox][selectedChannel];

      if (confirm(`⚠️ Kanal ${selectedChannel} in Box ${selectedBox} ist bereits belegt mit "${occupiedEffect.name}".\n\nTrotzdem zuweisen? (Überschreibt die vorherige Zuweisung)`)) {

        // Remove old assignment from the occupied effect

        const oldEffect = effects.find(e => e.id === occupiedEffect.id);

        if (oldEffect) {

          delete oldEffect.ignitionBox;

          delete oldEffect.ignitionChannel;

        }

      } else {

        return;

      }

    }

   

    // Remove any previous assignment of this effect

    if (selectedEffect.ignitionBox && selectedEffect.ignitionChannel) {

      if (ignitionBoxes[selectedEffect.ignitionBox] && ignitionBoxes[selectedEffect.ignitionBox][selectedEffect.ignitionChannel]) {

        delete ignitionBoxes[selectedEffect.ignitionBox][selectedEffect.ignitionChannel];

      }

    }

   

    // Assign to new box and channel

    selectedEffect.ignitionBox = selectedBox;

    selectedEffect.ignitionChannel = selectedChannel;

   

    // Update ignition boxes tracking

    if (!ignitionBoxes[selectedBox]) {

      ignitionBoxes[selectedBox] = {};

    }

    ignitionBoxes[selectedBox][selectedChannel] = {

      id: selectedEffect.id,

      name: selectedEffect.name,

      time: selectedEffect.timeStr,

      effectType: selectedEffect.effectType

    };

   

    // Update UI

    updateEffectList();

    updateCurrentSelection();

    drawCanvas();

   

    // Save to localStorage

    try {

      localStorage.setItem('ignitionBoxes', JSON.stringify(ignitionBoxes));

    } catch (saveError) {

      console.warn('⚠️ Konnte Zündanlagen nicht speichern:', saveError);

    }

   

    // Sync with collaborators

    if (isCollaborating) {

      syncWithCollaborators();

    }

   

    // Success feedback

    showSuccessMessage(`✅ "${selectedEffect.name}" zu Box ${selectedBox}-${selectedChannel} zugewiesen!`);

   

    // Visual feedback

    const assignButton = document.querySelector('button[onclick="assignToBox()"]');

    if (assignButton) {

      const originalText = assignButton.textContent;

      const originalBg = assignButton.style.background;

     

      assignButton.textContent = '✅ Zugewiesen!';

      assignButton.style.background = '#4caf50';

      assignButton.style.transform = 'scale(1.05)';

     

      setTimeout(() => {

        assignButton.textContent = originalText;

        assignButton.style.background = originalBg;

        assignButton.style.transform = 'scale(1)';

      }, 2000);

    }

   

    // Clear selection for next assignment

    setTimeout(() => {

      boxSelect.value = '';

      channelInput.value = '';

      selectedEffect = null;

      updateCurrentSelection();

    }, 2000);

   

  } catch (error) {

    console.error('❌ Fehler bei Zündanlagen-Zuweisung:', error);

    alert('❌ Fehler bei der Zuweisung: ' + error.message);

  }

}


function quickAssign(box, channel) {

  try {

    if (!selectedEffect) {

      alert('❌ Bitte zuerst einen Effekt auswählen!\n\nKlicke auf das 📡-Symbol neben einem Effekt.');

      return;

    }

   

    // Set the values and trigger assignment

    const boxSelect = document.getElementById('ignitionBox');

    const channelInput = document.getElementById('selectedChannel');

   

    if (boxSelect && channelInput) {

      boxSelect.value = box;

      channelInput.value = channel;

     

      // Visual feedback for quick assign

      const quickButton = event.target;

      if (quickButton) {

        quickButton.style.background = '#4caf50';

        quickButton.style.transform = 'scale(1.1)';

       

        setTimeout(() => {

          quickButton.style.background = '#2196f3';

          quickButton.style.transform = 'scale(1)';

        }, 1000);

      }

     

      // Trigger assignment

      assignToBox();

    }

  } catch (error) {

    console.error('❌ Fehler bei Schnell-Zuweisung:', error);

    alert('❌ Fehler bei Schnell-Zuweisung: ' + error.message);

  }

}


function showIgnitionOverview() {

  try {

    const overviewDiv = document.getElementById('ignitionOverview');

    const boxesDiv = document.getElementById('ignitionBoxes');

   

    if (!overviewDiv || !boxesDiv) return;

   

    let html = '';

   

    ['A', 'B', 'C', 'D', 'E', 'F'].forEach(boxName => {

      const box = ignitionBoxes[boxName] || {};

      const assignedChannels = Object.keys(box).length;

     

      html += `

        <div style="background: #222; margin: 10px 0; padding: 15px; border-radius: 8px; border-left: 4px solid #2196f3;">

          <h4 style="color: #2196f3; margin: 0 0 10px 0;">📡 Box ${boxName} (${assignedChannels}/32 Kanäle belegt)</h4>

      `;

     

      if (assignedChannels === 0) {

        html += '<p style="color: #666; font-style: italic;">Keine Effekte zugewiesen</p>';

      } else {

        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">';

       

        // Sort channels numerically

        const sortedChannels = Object.keys(box).sort((a, b) => parseInt(a) - parseInt(b));

       

        sortedChannels.forEach(channel => {

          const effect = box[channel];

          if (!effect) return;

         

          const typeColors = {

            rocket: '#ff4444',

            fountain: '#44ff44',

            battery: '#4444ff'

          };

         

          const typeColor = typeColors[effect.effectType] || '#ffffff';

         

          html += `

            <div style="background: #333; padding: 8px; border-radius: 5px; border-left: 3px solid ${typeColor};">

              <strong style="color: ${typeColor};">Kanal ${channel}</strong><br>

              <span style="color: #fff;">${escapeHtml(effect.name || 'Unbenannt')}</span><br>

              <span style="color: #ccc; font-size: 12px;">Zeit: ${escapeHtml(effect.time || '0:00')}</span><br>

              <span style="color: #ccc; font-size: 12px;">Typ: ${escapeHtml(effect.effectType || 'rocket')}</span>

              <button onclick="removeIgnitionAssignment('${boxName}', ${channel})"

                      style="background: #d32f2f; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 10px; float: right;">

                🗑️

              </button>

            </div>

          `;

        });

       

        html += '</div>';

      }

     

      html += '</div>';

    });

   

    boxesDiv.innerHTML = html;

    overviewDiv.style.display = 'block';

   

    // Scroll to overview

    overviewDiv.scrollIntoView({ behavior: 'smooth' });

   

  } catch (error) {

    console.error('❌ Fehler bei Zündanlagen-Übersicht:', error);

  }

}


function hideIgnitionOverview() {

  try {

    const overviewDiv = document.getElementById('ignitionOverview');

    if (overviewDiv) {

      overviewDiv.style.display = 'none';

    }

  } catch (error) {

    console.error('❌ Fehler beim Schließen der Übersicht:', error);

  }

}


function removeIgnitionAssignment(box, channel) {

  try {

    if (confirm(`Zuweisung von Box ${box}-${channel} wirklich entfernen?`)) {

      // Find and update the effect

      const assignedEffect = ignitionBoxes[box] && ignitionBoxes[box][channel];

      if (assignedEffect) {

        const effect = effects.find(e => e.id === assignedEffect.id);

        if (effect) {

          delete effect.ignitionBox;

          delete effect.ignitionChannel;

        }

      }

     

      // Remove from ignition boxes

      if (ignitionBoxes[box] && ignitionBoxes[box][channel]) {

        delete ignitionBoxes[box][channel];

      }

     

      // Update UI

      updateEffectList();

      drawCanvas();

      showIgnitionOverview(); // Refresh the overview

     

      // Save to localStorage

      try {

        localStorage.setItem('ignitionBoxes', JSON.stringify(ignitionBoxes));

      } catch (saveError) {

        console.warn('⚠️ Konnte Zündanlagen nicht speichern:', saveError);

      }

     

      // Sync with collaborators

      if (isCollaborating) {

        syncWithCollaborators();

      }

     

      showSuccessMessage(`✅ Zuweisung Box ${box}-${channel} entfernt!`);

    }

  } catch (error) {

    console.error('❌ Fehler beim Entfernen der Zuweisung:', error);

    alert('❌ Fehler beim Entfernen: ' + error.message);

  }

}


// ===== WEITERE PLATZHALTER-FUNKTIONEN =====

function loadSavedShows() {

  try {

    const saved = localStorage.getItem('savedShows');

    if (saved) {

      const shows = JSON.parse(saved);

      const select = document.getElementById('savedShows');

      if (select && Array.isArray(shows)) {

        select.innerHTML = '<option value="">Gespeicherte Shows</option>';

        shows.forEach((show, index) => {

          const option = document.createElement('option');

          option.value = index;

          option.textContent = escapeHtml(show.name || `Show ${index + 1}`);

          select.appendChild(option);

        });

      }

    }

  } catch (error) {

    console.error('❌ Fehler beim Laden der Shows:', error);

  }

}


function loadSavedEffects() {

  try {

    const saved = localStorage.getItem('savedEffects');

    if (saved) {

      savedEffects = JSON.parse(saved) || [];

    }

  } catch (error) {

    console.error('❌ Fehler beim Laden der Effekte:', error);

    savedEffects = [];

  }

}


function startAutoBackup() {

  try {

    if (autoBackupInterval) {

      clearInterval(autoBackupInterval);

    }

    autoBackupInterval = addManagedInterval(() => {

      try {

        localStorage.setItem('autoBackup_effects', JSON.stringify(effects));

        localStorage.setItem('autoBackup_ignitionBoxes', JSON.stringify(ignitionBoxes));

        localStorage.setItem('autoBackup_timestamp', new Date().toISOString());

      } catch (backupError) {

        console.warn('⚠️ Auto-Backup fehlgeschlagen:', backupError);

      }

    }, 30000); // Every 30 seconds

  } catch (error) {

    console.error('❌ Fehler beim Starten des Auto-Backups:', error);

  }

}


function initializeAudioContext() {

  try {

    if (typeof AudioContext !== 'undefined') {

      audioContext = new AudioContext();

    } else if (typeof webkitAudioContext !== 'undefined') {

      audioContext = new webkitAudioContext();

    }

  } catch (error) {

    console.warn('⚠️ Audio-Kontext nicht verfügbar:', error);

  }

}


function checkInventoryWarnings() {

  try {

    const warningDiv = document.getElementById('inventoryWarning');

    const lowStockDiv = document.getElementById('lowStockItems');

   

    if (!warningDiv || !lowStockDiv) return;

   

    const warnings = [];

   

    effects.forEach(effect => {

      const dbEffect = effectDatabase.find(e =>

        (e.name === effect.name) || (e.barcode && effect.barcode && e.barcode === effect.barcode)

      );

     

      if (dbEffect && typeof dbEffect.stockQuantity === 'number') {

        const needed = effect.quantity || 1;

        if (dbEffect.stockQuantity < needed) {

          warnings.push({

            name: effect.name,

            needed: needed,

            available: dbEffect.stockQuantity,

            missing: needed - dbEffect.stockQuantity

          });

        }

      }

    });

   

    if (warnings.length > 0) {

      let html = '<ul>';

      warnings.forEach(warning => {

        html += `<li>${escapeHtml(warning.name)}: Benötigt ${warning.needed}, verfügbar ${warning.available} (fehlen ${warning.missing})</li>`;

      });

      html += '</ul>';

     

      lowStockDiv.innerHTML = html;

      warningDiv.style.display = 'block';

    } else {

      warningDiv.style.display = 'none';

    }

  } catch (error) {

    console.error('❌ Fehler bei Lagerbestand-Prüfung:', error);

  }

}


function showIgnitionBoxDetails(boxName) {

  try {

    const box = ignitionBoxes[boxName] || {};

    const assignedChannels = Object.keys(box).length;

   

    let message = `📡 Zündbox ${boxName}\n\n`;

    message += `Belegte Kanäle: ${assignedChannels}/32\n\n`;

   

    if (assignedChannels === 0) {

      message += 'Keine Effekte zugewiesen';

    } else {

      message += 'Zugewiesene Effekte:\n';

     

      // Sort channels numerically

      const sortedChannels = Object.keys(box).sort((a, b) => parseInt(a) - parseInt(b));

     

      sortedChannels.forEach(channel => {

        const effect = box[channel];

        if (effect) {

          message += `\nKanal ${channel}: ${effect.name}`;

          message += `\n  Zeit: ${effect.time || '0:00'}`;

          message += `\n  Typ: ${effect.effectType || 'rocket'}`;

        }

      });

    }

   

    // Show alert with box details

    alert(message);

   

    // Also show the ignition overview

    showIgnitionOverview();

   

    // Highlight the specific box in the overview

    setTimeout(() => {

      const boxElements = document.querySelectorAll('h4');

      boxElements.forEach(element => {

        if (element.textContent.includes(`Box ${boxName}`)) {

          element.style.background = '#4caf50';

          element.style.color = 'white';

          element.style.padding = '5px';

          element.style.borderRadius = '3px';

          element.scrollIntoView({ behavior: 'smooth', block: 'center' });

         

          setTimeout(() => {

            element.style.background = '';

            element.style.color = '';

            element.style.padding = '';

            element.style.borderRadius = '';

          }, 3000);

        }

      });

    }, 500);

   

  } catch (error) {

    console.error('❌ Fehler bei Zündbox-Details:', error);

    alert(`❌ Fehler beim Anzeigen der Details für Box ${boxName}`);

  }

}


function resetBoxPositions() {

  try {

    if (confirm('🔄 Zündbox-Positionen auf Standard zurücksetzen?\n\nAlle Boxen werden wieder in der ursprünglichen Anordnung platziert.')) {

      // Reset to default positions

      ignitionBoxPositions = {

        A: { x: 50, y: 50 },

        B: { x: 150, y: 50 },

        C: { x: 250, y: 50 },

        D: { x: 50, y: 120 },

        E: { x: 150, y: 120 },

        F: { x: 250, y: 120 }

      };

     

      // Save to localStorage

      try {

        localStorage.setItem('ignitionBoxPositions', JSON.stringify(ignitionBoxPositions));

      } catch (saveError) {

        console.warn('⚠️ Konnte Box-Positionen nicht speichern:', saveError);

      }

     

      // Update canvas

      drawCanvas();

     

      // Sync with collaborators

      if (isCollaborating) {

        syncWithCollaborators();

      }

     

      showSuccessMessage('✅ Zündbox-Positionen zurückgesetzt!');

    }

  } catch (error) {

    console.error('❌ Fehler beim Zurücksetzen der Box-Positionen:', error);

    alert('❌ Fehler beim Zurücksetzen: ' + error.message);

  }

}


// Weitere Platzhalter-Funktionen...

function saveShow() { console.log('saveShow - Platzhalter'); }

function selectShow() { console.log('selectShow - Platzhalter'); }

function exportShow() { console.log('exportShow - Platzhalter'); }

function importShow() { console.log('importShow - Platzhalter'); }

function printPlan() { console.log('printPlan - Platzhalter'); }

function generateQRCode() { console.log('generateQRCode - Platzhalter'); }

function loadFromSession() { console.log('loadFromSession - Platzhalter'); }

function startCollaboration() { console.log('startCollaboration - Platzhalter'); }

function joinCollaboration() { console.log('joinCollaboration - Platzhalter'); }

function autoBackup() { console.log('autoBackup - Platzhalter'); }

function startShow() { console.log('startShow - Platzhalter'); }

function pauseShow() { console.log('pauseShow - Platzhalter'); }

function resumeShow() { console.log('resumeShow - Platzhalter'); }

function stopShow() { console.log('stopShow - Platzhalter'); }

function backToPlan() { console.log('backToPlan - Platzhalter'); }

function closeQRModal() { console.log('closeQRModal - Platzhalter'); }

function selectSavedEffect() { console.log('selectSavedEffect - Platzhalter'); }

function showSearch() { console.log('showSearch - Platzhalter'); }

function hideSearch() { console.log('hideSearch - Platzhalter'); }

function searchEffects() { console.log('searchEffects - Platzhalter'); }

function addToDatabase() { console.log('addToDatabase - Platzhalter'); }

function importExcelDatabase() { console.log('importExcelDatabase - Platzhalter'); }

function clearDatabase() { console.log('clearDatabase - Platzhalter'); }

function loadMusic() { console.log('loadMusic - Platzhalter'); }

function analyzeBeat() { console.log('analyzeBeat - Platzhalter'); }

function autoSyncEffects() { console.log('autoSyncEffects - Platzhalter'); }

function checkWeatherConditions() { console.log('checkWeatherConditions - Platzhalter'); }

function editEffect(id) { console.log('editEffect - Platzhalter:', id); }

function updateInventoryForEffect(effect) { console.log('updateInventoryForEffect - Platzhalter:', effect); }

function syncWithCollaborators() { console.log('syncWithCollaborators - Platzhalter'); }

function broadcastCursorPosition(x, y) { console.log('broadcastCursorPosition - Platzhalter:', x, y); }


// Cleanup beim Verlassen der Seite

window.addEventListener('beforeunload', function() {

  cleanup();

});


console.log('✅ FirePlanner 2D Pro Advanced - Korrigierte Version geladen!');

</script>

<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'987b2f0e63da9bf7',t:'MTc1OTMxMzU2OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>

</html>

