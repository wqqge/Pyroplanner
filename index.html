<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>üéÜ FirePlanner 2D - Pro</title>
<style>
body {
  box-sizing: border-box;
  font-family: Arial, sans-serif;
  margin: 0;
  background: #111;
  color: #eee;
}
h1, h2 {
  text-align: center;
  margin: 10px 0;
}
input, button, select, textarea {
  margin: 5px;
  padding: 8px;
  background: #222;
  color: #fff;
  border: 1px solid #555;
  border-radius: 5px;
  font-size: 14px;
  outline: none;
}

input:focus, textarea:focus, select:focus {
  background: #333;
  border-color: #4caf50;
  box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
}

input[type="text"], input[type="number"], textarea {
  width: 200px;
  max-width: 100%;
}
button {
  cursor: pointer;
  background: #444;
  transition: 0.2s;
  padding: 10px 15px;
}
button:hover {
  background: #666;
}
#container {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 20px;
}
#effectList {
  max-width: 400px;
  margin: 10px;
}
.effect-item {
  border: 1px solid #555;
  padding: 10px;
  margin: 8px 0;
  border-radius: 5px;
  background: #222;
  cursor: move;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.2s;
}
.effect-item:hover {
  background: #333;
  transform: translateY(-2px);
}
.effect-item.dragging {
  opacity: 0.5;
  transform: rotate(5deg);
}
#canvasContainer {
  position: relative;
  margin: 10px auto;
  border: 2px solid #555;
  background: #000;
  border-radius: 8px;
}
#fireworkCanvas {
  cursor: crosshair;
  display: block;
  border-radius: 6px;
}
.tooltip {
  position: relative;
  display: inline-block;
}
.tooltip .tooltiptext {
  visibility: hidden;
  width: 200px;
  background: #333;
  color: #fff;
  text-align: left;
  border-radius: 5px;
  padding: 8px;
  position: absolute;
  z-index: 1;
  bottom: 125%;
  left: 50%;
  margin-left: -100px;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
#timerDisplay {
  font-size: 3em;
  text-align: center;
  margin: 20px 0;
  font-weight: bold;
  color: #0ff;
}
#currentEffect {
  font-size: 1.4em;
  color: #ff0;
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #222;
  border-radius: 5px;
  min-height: 60px;
}
#warning {
  font-size: 2.5em;
  color: #f00;
  text-align: center;
  margin: 15px 0;
  font-weight: bold;
}
#timelineDisplay {
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #222;
  border-radius: 5px;
}
#printArea {
  display: none;
}
#warningFlash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: red;
  opacity: 0;
  pointer-events: none;
  border-radius: 5px;
  transition: opacity 0.1s;
}
.controls {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #222;
  border-radius: 8px;
}
.effect-delete {
  background: #d32f2f;
  color: white;
  border: none;
  padding: 5px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
}
.effect-delete:hover {
  background: #b71c1c;
}
#costCalculation {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #1a4d1a;
  border-radius: 8px;
  border: 2px solid #2e7d32;
}
#costCalculation h3 {
  margin: 0 0 10px 0;
  color: #4caf50;
}
#totalCost {
  font-size: 1.5em;
  font-weight: bold;
  color: #81c784;
}
#effectCount {
  color: #a5d6a7;
  margin-top: 5px;
}
.explosion {
  position: absolute;
  pointer-events: none;
  border-radius: 50%;
  animation: explode 1s ease-out forwards;
}
@keyframes explode {
  0% { transform: scale(0); opacity: 1; }
  50% { transform: scale(1.5); opacity: 0.8; }
  100% { transform: scale(3); opacity: 0; }
}
#qrModal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.8);
}
.modal-content {
  background-color: #222;
  margin: 15% auto;
  padding: 20px;
  border: 1px solid #555;
  border-radius: 10px;
  width: 300px;
  text-align: center;
}
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}
.close:hover {
  color: #fff;
}
#backupStatus {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #4caf50;
  color: white;
  padding: 10px;
  border-radius: 5px;
  display: none;
  z-index: 1000;
}
#effectOverview {
  text-align: center;
  margin: 20px 0;
  padding: 15px;
  background: #1a1a2e;
  border-radius: 8px;
  border: 2px solid #16213e;
}
#effectOverview h3 {
  margin: 0 0 15px 0;
  color: #0f3460;
}
#overviewTable {
  overflow-x: auto;
}
.overview-table {
  width: 100%;
  border-collapse: collapse;
  background: #222;
  border-radius: 5px;
  overflow: hidden;
}
.overview-table th {
  background: #333;
  color: #fff;
  padding: 10px 8px;
  text-align: left;
  font-size: 12px;
  border-bottom: 2px solid #555;
}
.overview-table td {
  padding: 8px;
  border-bottom: 1px solid #444;
  font-size: 11px;
  color: #ddd;
}
.overview-table tr:hover {
  background: #2a2a2a;
}
.time-cell {
  color: #4caf50;
  font-weight: bold;
}
.channel-cell {
  color: #2196f3;
  font-weight: bold;
}
.button-cell {
  color: #ff9800;
  font-weight: bold;
}
.database-info {
  background: #2a2a2a;
  padding: 10px;
  border-radius: 5px;
  margin: 10px 0;
  font-size: 12px;
  color: #ccc;
}
.image-preview {
  max-width: 200px;
  max-height: 150px;
  border-radius: 5px;
  border: 2px solid #555;
  margin: 10px 0;
}
.effect-image {
  max-width: 50px;
  max-height: 50px;
  border-radius: 3px;
  margin-right: 10px;
  vertical-align: middle;
}
.database-item {
  display: flex;
  align-items: center;
  padding: 5px;
  margin: 2px 0;
  background: #333;
  border-radius: 3px;
}
.database-item img {
  margin-right: 10px;
}
</style>
</head>
<body>

<h1>üéÜ FirePlanner 2D - Pro</h1>

<div id="planScreen">
<h2>Show-Name</h2>
<input id="showName" placeholder="Name der Show">

<h2>Effekt hinzuf√ºgen</h2>
<select id="effectSavedList" onchange="selectSavedEffect()">
  <option value="">Vorherige Effekte</option>
</select>
<div style="position: relative; display: inline-block;">
  <select id="effectDatabase" onchange="selectFromDatabase()">
    <option value="">Effekt-Datenbank</option>
  </select>
  <input type="text" id="effectSearch" placeholder="üîç Effekt suchen..." 
         style="display: none; position: absolute; top: 0; left: 0; width: 100%; z-index: 10;"
         onkeyup="searchEffects()" onblur="hideSearch()">
</div>
<button onclick="showSearch()" id="searchButton" style="display: none;">üîç Suchen</button><br>

<div class="database-info">
  üìä <strong>Excel-Import Format:</strong> Name | Barcode | Dauer | Preis | Typ<br>
  Beispiel: "Goldener Regen | 4260123456789 | 0:15 | 12.50 | rocket"<br>
  üì∏ <strong>Bilder:</strong> Optional - k√∂nnen einzeln hochgeladen werden
</div>

<h3>üì∏ Bild f√ºr Effekt (Optional)</h3>
<input type="file" id="effectImage" accept="image/*" onchange="previewImage()">
<div id="imagePreview" style="margin: 10px 0;"></div>
<button onclick="clearImage()">üóëÔ∏è Bild entfernen</button>

<input id="name" placeholder="Effektname">
<select id="effectType">
  <option value="rocket">Rakete</option>
  <option value="fountain">Font√§ne</option>
  <option value="battery">Batterie</option>
</select>
<input id="plannedDuration" placeholder="Dauer (m:s)">
<input id="price" placeholder="Preis (‚Ç¨)" type="number" step="0.01">
<input id="barcode" placeholder="Barcode/EAN">
<input id="time" placeholder="Showzeit (m:s)">
<input id="channel" placeholder="Kanal">
<input id="receiver" placeholder="Empf√§nger">
<input id="buttonKey" placeholder="Taste">
<input id="quantity" placeholder="Anzahl Effekte">
<textarea id="additionalInfo" placeholder="Zusatzinfos"></textarea>
<button onclick="addEffect()">Effekt speichern</button>
<button onclick="addToDatabase()">Zur Datenbank hinzuf√ºgen</button>
<input type="file" id="excelImport" accept=".csv,.txt,.tsv" onchange="importExcelDatabase()">
<button onclick="document.getElementById('excelImport').click()">üìä Excel-Datenbank importieren</button>
<button onclick="clearDatabase()">üóëÔ∏è Datenbank leeren</button>

<div id="container">
  <div id="canvasContainer">
    <canvas id="fireworkCanvas" width="800" height="500"></canvas>
    <div id="warningFlash"></div>
  </div>
  <div id="effectList"></div>
</div>

<div id="costCalculation">
  <h3>üí∞ Kostenkalkulation</h3>
  <div id="totalCost">Gesamtkosten: 0,00 ‚Ç¨</div>
  <div id="effectCount">Anzahl Effekte: 0</div>
</div>

<div id="effectOverview">
  <h3>üìã Effekt-√úbersicht</h3>
  <div id="overviewTable"></div>
</div>

<h2>Musik</h2>
<input type="file" id="musicFile" accept="audio/*" onchange="loadMusic()">

<div class="controls">
<button onclick="saveShow()">Show speichern</button>
<button onclick="loadSavedShows()">Show laden</button>
<select id="savedShows" onchange="selectShow()">
  <option value="">Gespeicherte Shows</option>
</select>
<button onclick="exportShow()">Export JSON</button>
<input type="file" id="importFile" accept=".json" onchange="importShow()">
<button onclick="importShow()">Import JSON</button>
<button onclick="printPlan()">Druckversion</button>
<button onclick="generateQRCode()">üì± Smartphone-Steuerung</button>
<button onclick="loadFromSession()">üîó Session laden</button>
<button onclick="autoBackup()">üíæ Auto-Backup</button>
<button onclick="startShow()">Show starten</button>
<button onclick="pauseShow()">Pause</button>
<button onclick="resumeShow()">Fortsetzen</button>
<button onclick="stopShow()">Stopp</button>
    <!-- ‚úÖ NEU: GitHub Cloud Buttons -->
    <button onclick="githubBackup()">‚òÅÔ∏è GitHub-Backup hochladen</button>
    <button onclick="githubRestore()">‚òÅÔ∏è GitHub-Backup laden</button>

</div>
</div>

<div id="showScreen" style="display:none;">
<h2>Show Timer</h2>
<div id="timerDisplay">00:00</div>
<div id="warning"></div>
<div id="currentEffect"></div>
<div id="timelineDisplay"></div>
<button onclick="backToPlan()" style="margin: 20px;">Zur√ºck zur Planung</button>
</div>

<div class="print-area" id="printArea"></div>

<!-- QR Code Modal -->
<div id="qrModal">
  <div class="modal-content">
    <span class="close" onclick="closeQRModal()">&times;</span>
    <h3>üì± Smartphone-Steuerung</h3>
    <div id="qrCode"></div>
    <p>Scanne den QR-Code mit deinem Smartphone</p>
    <div id="remoteUrl"></div>
  </div>
</div>

<div id="backupStatus">Backup erstellt!</div>

<audio id="warningBeep" preload="auto">
  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
</audio>
<audio id="fireBeep" preload="auto">
  <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
</audio>
<audio id="musicPlayer"></audio>

<script>
let effects = [];
let showTimer = null;
let showStartTime = 0;
let isPaused = false;
let pausedTime = 0;
let canvas, ctx;
let savedEffects = [];
let effectDatabase = [];
let draggedEffect = null;
let autoBackupInterval = null;
let currentEffectImage = null;

// Initialize canvas and load data
window.onload = function() {
  canvas = document.getElementById('fireworkCanvas');
  ctx = canvas.getContext('2d');
  loadSavedShows();
  loadSavedEffects();
  loadEffectDatabase();
  drawCanvas();
  startAutoBackup();
  
  // Canvas click handler
  canvas.addEventListener('click', function(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Finde nicht platzierte Effekte
    const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);
    
    if (unplacedEffects.length > 0) {
      const effectToPlace = unplacedEffects[0];
      effectToPlace.x = x;
      effectToPlace.y = y;
      updateEffectList();
      drawCanvas();
      
      // Zeige Best√§tigung
      const tempMsg = document.createElement('div');
      tempMsg.style.cssText = `
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background: #4caf50; color: white; padding: 10px 20px;
        border-radius: 5px; z-index: 1000; font-weight: bold;
      `;
      tempMsg.textContent = `‚úÖ "${effectToPlace.name}" platziert!`;
      document.body.appendChild(tempMsg);
      
      setTimeout(() => {
        if (tempMsg.parentNode) {
          tempMsg.parentNode.removeChild(tempMsg);
        }
      }, 2000);
    }
  });
  
  // Drag and drop for canvas
  canvas.addEventListener('dragover', function(e) {
    e.preventDefault();
  });
  
  canvas.addEventListener('drop', function(e) {
    e.preventDefault();
    if (draggedEffect) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      draggedEffect.x = x;
      draggedEffect.y = y;
      updateEffectList();
      drawCanvas();
      draggedEffect = null;
    }
  });
};

// Image handling functions
function previewImage() {
  const fileInput = document.getElementById('effectImage');
  const file = fileInput.files[0];
  const previewDiv = document.getElementById('imagePreview');
  
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      currentEffectImage = e.target.result;
      previewDiv.innerHTML = `<img src="${currentEffectImage}" class="image-preview" alt="Effekt Vorschau">`;
    };
    reader.readAsDataURL(file);
  } else {
    clearImage();
  }
}

function clearImage() {
  currentEffectImage = null;
  document.getElementById('imagePreview').innerHTML = '';
  document.getElementById('effectImage').value = '';
}

function initializeDatabase() {
  // Diese Funktion wird nur noch f√ºr manuelle Initialisierung verwendet
  // Keine automatischen Beispiel-Effekte mehr!
  console.log('‚ö†Ô∏è initializeDatabase() aufgerufen - sollte nicht automatisch passieren!');
  
  const sampleEffects = [
    {name: "Goldener Regen", duration: "0:15", price: 12.50, barcode: "4260123456789", effectType: "fountain"},
    {name: "Silber Rakete", duration: "0:03", price: 8.90, barcode: "4260123456790", effectType: "rocket"},
    {name: "Bunte Batterie", duration: "0:45", price: 25.00, barcode: "4260123456791", effectType: "battery"},
    {name: "Rote Sterne", duration: "0:08", price: 15.20, barcode: "4260123456792", effectType: "rocket"},
    {name: "Gr√ºne Font√§ne", duration: "0:20", price: 18.75, barcode: "4260123456793", effectType: "fountain"}
  ];
  
  effectDatabase = sampleEffects;
  localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
  updateDatabaseList();
  console.log('‚úÖ Beispiel-Datenbank manuell erstellt');
}

function loadEffectDatabase() {
  console.log('üîß Lade Effekt-Datenbank...');
  
  const saved = localStorage.getItem('effectDatabase');
  if (saved) {
    try {
      const parsedDatabase = JSON.parse(saved);
      console.log('‚úÖ Datenbank aus LocalStorage geladen:', parsedDatabase.length, 'Effekte');
      console.log('üìã Geladene Effekte:', parsedDatabase);
      
      // Validiere Datenbank-Struktur
      if (!Array.isArray(parsedDatabase)) {
        console.error('‚ùå Datenbank ist kein Array, erstelle leere Datenbank...');
        effectDatabase = [];
        localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
        updateDatabaseList();
        return;
      }
      
      // Setze die Datenbank - auch wenn sie leer ist!
      effectDatabase = parsedDatabase;
      console.log('‚úÖ Datenbank erfolgreich geladen, aktualisiere Dropdown...');
      updateDatabaseList();
      
      // Zeige Status-Meldung
      if (effectDatabase.length === 0) {
        console.log('‚ÑπÔ∏è Datenbank ist leer - das ist OK!');
      } else {
        console.log(`‚úÖ ${effectDatabase.length} Effekte erfolgreich geladen`);
        // Zeige die ersten paar Effekte zur Best√§tigung
        effectDatabase.slice(0, 3).forEach((effect, i) => {
          console.log(`${i + 1}. ${effect.name} - ${effect.addedDate ? new Date(effect.addedDate).toLocaleString() : 'Kein Datum'}`);
        });
      }
      
    } catch (error) {
      console.error('‚ùå Fehler beim Laden der Datenbank:', error);
      console.log('üîß Erstelle leere Datenbank wegen Fehler...');
      effectDatabase = [];
      localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
      updateDatabaseList();
      return;
    }
  } else {
    console.log('üîß Keine Datenbank gefunden, erstelle leere Datenbank...');
    effectDatabase = [];
    localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
    updateDatabaseList();
    console.log('‚úÖ Leere Datenbank erstellt');
  }
}

function updateDatabaseList() {
  console.log('üîß Starte Dropdown-Aktualisierung...');
  
  const select = document.getElementById('effectDatabase');
  
  if (!select) {
    console.error('‚ùå Dropdown-Element "effectDatabase" nicht gefunden!');
    return;
  }
  
  console.log(`üìä Aktualisiere Dropdown mit ${effectDatabase.length} Effekten`);
  
  // Zeige aktuellen Datenbank-Status in der Konsole
  console.log('üìã Aktuelle Datenbank-Inhalte:');
  if (effectDatabase.length === 0) {
    console.log('üìù Datenbank ist leer');
  } else {
    effectDatabase.forEach((effect, index) => {
      console.log(`${index + 1}. ${effect.name} - ${effect.price || 0}‚Ç¨ - ${effect.barcode || 'Kein Barcode'} - ${effect.addedDate ? new Date(effect.addedDate).toLocaleString() : 'Kein Datum'}`);
    });
  }
  
  // Pr√ºfe LocalStorage-Konsistenz
  const stored = localStorage.getItem('effectDatabase');
  if (stored) {
    try {
      const storedDatabase = JSON.parse(stored);
      if (storedDatabase.length !== effectDatabase.length) {
        console.warn('‚ö†Ô∏è WARNUNG: LocalStorage und Variable sind inkonsistent!');
        console.warn('Variable:', effectDatabase.length, 'LocalStorage:', storedDatabase.length);
      } else {
        console.log('‚úÖ LocalStorage und Variable sind konsistent');
      }
    } catch (error) {
      console.error('‚ùå Fehler beim Pr√ºfen des LocalStorage:', error);
    }
  }
  
  // Performance-optimierte Aktualisierung f√ºr gro√üe Datenbanken
  if (effectDatabase.length > 100) {
    console.log('‚ö° Verwende Performance-Modus f√ºr gro√üe Datenbank');
    
    // Zeige Suchbutton f√ºr gro√üe Datenbanken
    const searchButton = document.getElementById('searchButton');
    if (searchButton) {
      searchButton.style.display = 'inline-block';
    }
    
    // Leere das Dropdown
    select.innerHTML = '';
    
    // Standard-Option
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = `üìä Datenbank (${effectDatabase.length} Effekte) - Suchbutton nutzen`;
    select.appendChild(defaultOption);
    
    // Nur erste 20 Effekte laden f√ºr bessere Performance
    const maxDisplay = Math.min(20, effectDatabase.length);
    
    for (let i = 0; i < maxDisplay; i++) {
      const effect = effectDatabase[i];
      const option = document.createElement('option');
      option.value = i.toString();
      
      // Sehr kurze Anzeige f√ºr Performance
      const price = (effect.price && effect.price > 0) ? ` ${effect.price}‚Ç¨` : '';
      const shortName = effect.name.length > 20 ? effect.name.substring(0, 20) + '...' : effect.name;
      
      option.textContent = `${shortName}${price}`;
      select.appendChild(option);
    }
    
    if (effectDatabase.length > maxDisplay) {
      const moreOption = document.createElement('option');
      moreOption.value = 'search';
      moreOption.textContent = `... ${effectDatabase.length - maxDisplay} weitere ‚Üí Suchbutton nutzen`;
      moreOption.disabled = true;
      select.appendChild(moreOption);
    }
    
  } else {
    // Normale Aktualisierung f√ºr kleinere Datenbanken
    // Verstecke Suchbutton f√ºr kleine Datenbanken
    const searchButton = document.getElementById('searchButton');
    if (searchButton) {
      searchButton.style.display = 'none';
    }
    
    select.innerHTML = '';
    
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = `üìä Effekt-Datenbank (${effectDatabase.length} Effekte)`;
    select.appendChild(defaultOption);
    
    effectDatabase.forEach((effect, index) => {
      const option = document.createElement('option');
      option.value = index.toString();
      
      const price = (effect.price && effect.price > 0) ? `${effect.price}‚Ç¨` : '';
      const duration = effect.duration || effect.plannedDuration || '';
      const type = effect.effectType || effect.type || '';
      const hasImage = effect.image ? 'üì∏ ' : '';
      
      option.textContent = `${hasImage}${effect.name} ${price ? '- ' + price : ''} ${duration ? '- ' + duration : ''} ${type ? '- ' + type : ''}`;
      select.appendChild(option);
    });
  }
  
  console.log('‚úÖ Dropdown aktualisiert!');
}

function selectFromDatabase() {
  const select = document.getElementById('effectDatabase');
  const selectedValue = select.value;
  
  console.log('üîç Datenbank-Auswahl gestartet:', {
    selectedValue: selectedValue,
    databaseLength: effectDatabase.length,
    database: effectDatabase
  });
  
  // Pr√ºfe ob ein Wert ausgew√§hlt wurde
  if (!selectedValue || selectedValue === '') {
    console.log('‚ÑπÔ∏è Keine Auswahl getroffen');
    return;
  }
  
  const index = parseInt(selectedValue);
  console.log('üî¢ Index berechnet:', index);
  
  // Validiere Index
  if (isNaN(index) || index < 0 || index >= effectDatabase.length) {
    console.error('‚ùå Ung√ºltiger Index:', {
      originalValue: selectedValue,
      parsedIndex: index,
      isNaN: isNaN(index),
      tooSmall: index < 0,
      tooLarge: index >= effectDatabase.length,
      databaseLength: effectDatabase.length
    });
    alert(`‚ùå Fehler: Ung√ºltiger Index ${index} f√ºr Datenbank mit ${effectDatabase.length} Eintr√§gen!`);
    return;
  }
  
  const effect = effectDatabase[index];
  console.log('üìã Effekt gefunden:', effect);
  
  if (!effect) {
    console.error('‚ùå Effekt nicht gefunden bei Index:', index);
    alert('‚ùå Effekt nicht gefunden!');
    return;
  }
  
  try {
    // Felder f√ºllen mit Validierung
    const fields = {
      name: document.getElementById('name'),
      effectType: document.getElementById('effectType'),
      plannedDuration: document.getElementById('plannedDuration'),
      price: document.getElementById('price'),
      barcode: document.getElementById('barcode')
    };
    
    // Pr√ºfe ob alle Felder existieren
    for (const [fieldName, field] of Object.entries(fields)) {
      if (!field) {
        console.error(`‚ùå Feld ${fieldName} nicht gefunden!`);
        alert(`‚ùå Eingabefeld ${fieldName} nicht gefunden!`);
        return;
      }
    }
    
    // F√ºlle die Felder
    fields.name.value = effect.name || '';
    fields.effectType.value = effect.effectType || effect.type || 'rocket';
    fields.plannedDuration.value = effect.duration || effect.plannedDuration || '';
    fields.price.value = effect.price || '';
    fields.barcode.value = effect.barcode || '';
    
    console.log('‚úÖ Felder gef√ºllt:', {
      name: fields.name.value,
      type: fields.effectType.value,
      duration: fields.plannedDuration.value,
      price: fields.price.value,
      barcode: fields.barcode.value
    });
    
    // Load image if available
    if (effect.image) {
      currentEffectImage = effect.image;
      const previewDiv = document.getElementById('imagePreview');
      if (previewDiv) {
        previewDiv.innerHTML = `<img src="${currentEffectImage}" class="image-preview" alt="Effekt Bild">`;
        console.log('üì∏ Bild geladen');
      }
    } else {
      clearImage();
      console.log('üö´ Kein Bild vorhanden');
    }
    
    // Visuelles Feedback - gr√ºnes Aufleuchten
    fields.name.style.background = '#2d5a2d';
    fields.name.style.borderColor = '#4caf50';
    fields.name.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
    
    setTimeout(() => {
      fields.name.style.background = '#222';
      fields.name.style.borderColor = '#555';
      fields.name.style.boxShadow = 'none';
    }, 2000);
    
    // Success message
    const imageText = effect.image ? ' üì∏' : '';
    const priceText = effect.price ? ` - ${effect.price}‚Ç¨` : '';
    
    console.log(`‚úÖ Effekt "${effect.name}"${imageText}${priceText} erfolgreich geladen!`);
    
    // Show temporary success message
    const tempMsg = document.createElement('div');
    tempMsg.style.cssText = `
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: #4caf50; color: white; padding: 15px 25px;
      border-radius: 8px; z-index: 1000; font-weight: bold;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    tempMsg.textContent = `‚úÖ "${effect.name}" aus Datenbank geladen!${imageText}`;
    document.body.appendChild(tempMsg);
    
    setTimeout(() => {
      if (tempMsg.parentNode) {
        tempMsg.parentNode.removeChild(tempMsg);
      }
    }, 3000);
    
  } catch (error) {
    console.error('‚ùå Fehler beim Laden des Effekts:', error);
    alert('‚ùå Fehler beim Laden des Effekts: ' + error.message);
  }
}

function addToDatabase() {
  const name = document.getElementById('name').value;
  const effectType = document.getElementById('effectType').value;
  const duration = document.getElementById('plannedDuration').value;
  const price = parseFloat(document.getElementById('price').value) || 0;
  const barcode = document.getElementById('barcode').value;
  
  if (!name) {
    alert('Bitte mindestens Name eingeben!');
    return;
  }
  
  const newEffect = {
    name, 
    effectType, 
    duration, 
    price, 
    barcode,
    image: currentEffectImage, // Add image if available
    addedDate: new Date().toISOString() // Zeitstempel hinzuf√ºgen
  };
  
  console.log('üíæ F√ºge Effekt zur Datenbank hinzu:', newEffect);
  console.log('üìä Datenbank vor dem Hinzuf√ºgen:', effectDatabase.length, 'Effekte');
  
  // Pr√ºfe LocalStorage vor dem Hinzuf√ºgen
  const beforeStorage = localStorage.getItem('effectDatabase');
  console.log('üìã LocalStorage vor √Ñnderung:', beforeStorage ? JSON.parse(beforeStorage).length : 0, 'Effekte');
  
  effectDatabase.push(newEffect);
  console.log('üìä Datenbank nach dem Hinzuf√ºgen:', effectDatabase.length, 'Effekte');
  
  // Speichere mit umfassender Validierung
  try {
    const jsonString = JSON.stringify(effectDatabase);
    console.log('üíæ Speichere JSON-String mit', jsonString.length, 'Zeichen');
    
    localStorage.setItem('effectDatabase', jsonString);
    console.log('üíæ LocalStorage.setItem() ausgef√ºhrt');
    
    // Sofortige Verifikation der Speicherung
    const verification = localStorage.getItem('effectDatabase');
    if (verification) {
      const parsed = JSON.parse(verification);
      console.log('‚úÖ Speicherung verifiziert:', parsed.length, 'Effekte im LocalStorage');
      
      // Pr√ºfe ob der neue Effekt wirklich drin ist
      const lastEffect = parsed[parsed.length - 1];
      if (lastEffect && lastEffect.name === name && lastEffect.addedDate === newEffect.addedDate) {
        console.log('‚úÖ Neuer Effekt erfolgreich gespeichert:', lastEffect.name);
        console.log('üìã Effekt-Details:', lastEffect);
        console.log('üïí Hinzugef√ºgt am:', new Date(lastEffect.addedDate).toLocaleString());
      } else {
        console.error('‚ùå KRITISCHER FEHLER: Neuer Effekt nicht korrekt in LocalStorage!');
        console.error('Erwartet:', name, 'mit Datum:', newEffect.addedDate);
        console.error('Gefunden:', lastEffect ? lastEffect.name : 'nichts', 'mit Datum:', lastEffect ? lastEffect.addedDate : 'kein Datum');
        alert('‚ùå KRITISCHER FEHLER: Effekt wurde nicht korrekt gespeichert!');
        return;
      }
      
      // Zus√§tzliche Konsistenz-Pr√ºfung
      if (parsed.length !== effectDatabase.length) {
        console.error('‚ùå INKONSISTENZ: LocalStorage und Variable haben unterschiedliche L√§ngen!');
        console.error('Variable:', effectDatabase.length, 'LocalStorage:', parsed.length);
        alert('‚ùå WARNUNG: Inkonsistenz zwischen Speicher und Variable!');
      } else {
        console.log('‚úÖ Variable und LocalStorage sind konsistent');
      }
    } else {
      console.error('‚ùå KRITISCHER FEHLER: Nichts im LocalStorage gespeichert!');
      alert('‚ùå KRITISCHER FEHLER: Speicherung fehlgeschlagen - LocalStorage leer!');
      return;
    }
  } catch (error) {
    console.error('‚ùå Fehler beim Speichern des Effekts:', error);
    console.error('‚ùå Error Stack:', error.stack);
    alert('‚ùå Fehler beim Speichern! M√∂glicherweise ist der Browser-Speicher voll.\n\nFehler: ' + error.message);
    return;
  }
  
  updateDatabaseList();
  
  const imageText = currentEffectImage ? ' (mit Bild)' : '';
  alert(`‚úÖ Effekt "${name}"${imageText} zur Datenbank hinzugef√ºgt!\n\nüìä Datenbank hat jetzt ${effectDatabase.length} Effekte.\nüïí Hinzugef√ºgt: ${new Date().toLocaleString()}`);
  
  // Clear form after adding
  clearImage();
}

function clearDatabase() {
  if (confirm('Wirklich die komplette Datenbank l√∂schen?\nDies kann nicht r√ºckg√§ngig gemacht werden!')) {
    effectDatabase = [];
    localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
    updateDatabaseList();
    console.log('‚úÖ Datenbank geleert - bleibt leer bis neue Effekte hinzugef√ºgt werden');
    alert('Datenbank geleert! Sie bleibt leer bis Sie neue Effekte hinzuf√ºgen.');
  }
}

function importExcelDatabase() {
  const fileInput = document.getElementById('excelImport');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Bitte eine Excel/CSV-Datei ausw√§hlen!');
    return;
  }
  
  console.log('üìä Starte Excel-Import...');
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const text = e.target.result;
      const lines = text.split('\n');
      const newEffects = [];
      let skippedLines = 0;
      let processedLines = 0;
      
      console.log(`üìã Verarbeite ${lines.length} Zeilen...`);
      
      // Verarbeite alle Zeilen (auch erste Zeile falls keine √úberschrift)
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line) {
          processedLines++;
          
          // Versuche verschiedene Trennzeichen: Tab, Semikolon, Komma, Pipe
          let columns = [];
          
          if (line.includes('\t')) {
            columns = line.split('\t');
          } else if (line.includes(';')) {
            columns = line.split(';');
          } else if (line.includes('|')) {
            columns = line.split('|');
          } else if (line.includes(',')) {
            columns = line.split(',');
          } else {
            // Fallback: Leerzeichen als Trenner
            columns = line.split(/\s+/);
          }
          
          // Bereinige Spalten von Anf√ºhrungszeichen
          columns = columns.map(col => col.trim().replace(/^["']|["']$/g, ''));
          
          console.log(`Zeile ${i + 1}: ${columns.length} Spalten:`, columns);
          
          if (columns.length >= 2) {
            // √úberspringe Kopfzeilen (enthalten oft "Name", "Barcode", etc.)
            const firstCol = columns[0].toLowerCase();
            if (firstCol.includes('name') || firstCol.includes('effekt') || firstCol.includes('artikel')) {
              console.log(`√úberspringe Kopfzeile: ${columns[0]}`);
              continue;
            }
            
            const effect = {
              name: columns[0] || `Effekt ${newEffects.length + 1}`,
              barcode: columns[1] || '',
              duration: columns[2] || '',
              price: columns[3] ? parseFloat(columns[3].replace(',', '.')) || 0 : 0,
              effectType: columns[4] || 'rocket'
            };
            
            // Validiere Mindestanforderungen
            if (effect.name && effect.name.length > 0) {
              newEffects.push(effect);
              console.log(`‚úÖ Effekt hinzugef√ºgt: ${effect.name}`);
            } else {
              skippedLines++;
              console.log(`‚ùå Zeile √ºbersprungen: Kein Name`);
            }
          } else {
            skippedLines++;
            console.log(`‚ùå Zeile √ºbersprungen: Zu wenige Spalten (${columns.length})`);
          }
        }
      }
      
      console.log(`üìä Import-Ergebnis: ${newEffects.length} neue Effekte, ${skippedLines} √ºbersprungen`);
      
      if (newEffects.length > 0) {
        // F√ºge neue Effekte zur bestehenden Datenbank hinzu
        const oldCount = effectDatabase.length;
        effectDatabase = effectDatabase.concat(newEffects);
        
        // Speichere in LocalStorage mit Validierung
        try {
          localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
          console.log('üíæ Datenbank erfolgreich gespeichert:', effectDatabase.length, 'Effekte');
          
          // Verifikation der Speicherung
          const verification = localStorage.getItem('effectDatabase');
          if (verification) {
            const parsed = JSON.parse(verification);
            console.log('‚úÖ Speicherung verifiziert:', parsed.length, 'Effekte');
          }
        } catch (error) {
          console.error('‚ùå Fehler beim Speichern der Datenbank:', error);
          alert('‚ùå Fehler beim Speichern der Datenbank! M√∂glicherweise ist der Speicher voll.');
          return;
        }
        
        // Aktualisiere UI
        updateDatabaseList();
        
        let message = `‚úÖ ${newEffects.length} Effekte erfolgreich importiert!\n`;
        message += `üìä Datenbank: ${oldCount} ‚Üí ${effectDatabase.length} Effekte\n`;
        if (skippedLines > 0) {
          message += `‚ö†Ô∏è ${skippedLines} von ${processedLines} Zeilen √ºbersprungen`;
        }
        
        alert(message);
        
        // Zeige erste paar importierte Effekte zur Kontrolle
        console.log('üéÜ Erste importierte Effekte:');
        newEffects.slice(0, 5).forEach((effect, i) => {
          console.log(`${i + 1}. ${effect.name} - ${effect.price}‚Ç¨ - ${effect.barcode}`);
        });
        
      } else {
        alert(`‚ùå Keine g√ºltigen Effekte gefunden!\n\nüìã Verarbeitete Zeilen: ${processedLines}\n‚ö†Ô∏è √úbersprungene Zeilen: ${skippedLines}\n\nüí° Format-Beispiele:\n‚Ä¢ Name;Barcode;Dauer;Preis;Typ\n‚Ä¢ Name|Barcode|Dauer|Preis|Typ\n‚Ä¢ Name,Barcode,Dauer,Preis,Typ`);
      }
    } catch (error) {
      console.error('‚ùå Import-Fehler:', error);
      alert(`‚ùå Fehler beim Importieren der Datei!\n\nFehler: ${error.message}\n\nüí° Tipps:\n‚Ä¢ Datei als UTF-8 speichern\n‚Ä¢ Trennzeichen: ; | , oder Tab\n‚Ä¢ Mindestens Name und Barcode`);
    }
  };
  
  reader.readAsText(file, 'UTF-8');
}

function parseTime(timeStr) {
  if (!timeStr) return 0;
  const parts = timeStr.split(':');
  if (parts.length === 2) {
    return parseInt(parts[0]) * 60 + parseInt(parts[1]);
  }
  return parseInt(timeStr) || 0;
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function addEffect() {
  const name = document.getElementById('name').value;
  const effectType = document.getElementById('effectType').value;
  const plannedDuration = document.getElementById('plannedDuration').value;
  const price = parseFloat(document.getElementById('price').value) || 0;
  const barcode = document.getElementById('barcode').value;
  const time = document.getElementById('time').value;
  const channel = document.getElementById('channel').value;
  const receiver = document.getElementById('receiver').value;
  const buttonKey = document.getElementById('buttonKey').value;
  const quantity = parseInt(document.getElementById('quantity').value) || 1;
  const additionalInfo = document.getElementById('additionalInfo').value;
  
  if (!name || !time) {
    alert('Bitte mindestens Name und Showzeit eingeben!');
    return;
  }
  
  const effect = {
    id: Date.now(),
    name,
    effectType,
    plannedDuration,
    price,
    barcode,
    time: parseTime(time),
    timeStr: time,
    channel,
    receiver,
    buttonKey,
    quantity,
    additionalInfo,
    image: currentEffectImage, // Add image if available
    x: null, // Muss manuell platziert werden
    y: null
  };
  
  effects.push(effect);
  
  // Save to saved effects
  if (!savedEffects.find(e => e.name === name)) {
    savedEffects.push({
      name,
      effectType,
      plannedDuration,
      price,
      barcode,
      channel,
      receiver,
      buttonKey,
      quantity,
      additionalInfo
    });
    localStorage.setItem('savedEffects', JSON.stringify(savedEffects));
    updateSavedEffectsList();
  }
  
  // Clear form
  document.getElementById('name').value = '';
  document.getElementById('plannedDuration').value = '';
  document.getElementById('price').value = '';
  document.getElementById('barcode').value = '';
  document.getElementById('time').value = '';
  document.getElementById('channel').value = '';
  document.getElementById('receiver').value = '';
  document.getElementById('buttonKey').value = '';
  document.getElementById('quantity').value = '';
  document.getElementById('additionalInfo').value = '';
  clearImage(); // Clear image as well
  
  updateEffectList();
  updateCostCalculation();
  drawCanvas();
}

function updateEffectList() {
  const list = document.getElementById('effectList');
  list.innerHTML = '<h3>Effekte in der Show</h3>';
  
  effects.sort((a, b) => a.time - b.time);
  
  effects.forEach(effect => {
    const div = document.createElement('div');
    div.className = 'effect-item';
    div.draggable = true;
    div.innerHTML = `
      <div style="display: flex; align-items: center;">
        ${effect.image ? `<img src="${effect.image}" class="effect-image" alt="Effekt">` : ''}
        <div>
          <strong>${effect.name}</strong><br>
          Zeit: ${effect.timeStr} | Typ: ${effect.effectType}<br>
          Kanal: ${effect.channel || 'Nicht gesetzt'} | Taste: ${effect.buttonKey || 'Nicht gesetzt'}<br>
          ${effect.price > 0 ? `Preis: ${effect.price.toFixed(2)}‚Ç¨ | ` : ''}Anzahl: ${effect.quantity}<br>
          Position: ${effect.x ? `X:${Math.round(effect.x)}, Y:${Math.round(effect.y)}` : 'Nicht platziert'}
        </div>
      </div>
      <div style="display: flex; gap: 5px;">
        <button class="effect-edit" onclick="editEffect(${effect.id})" style="background: #2196f3; color: white; border: none; padding: 5px 8px; border-radius: 3px; cursor: pointer; font-size: 12px;">‚úèÔ∏è</button>
        <button class="effect-delete" onclick="deleteEffect(${effect.id})">√ó</button>
      </div>
    `;
    
    // Add drag handlers
    div.addEventListener('dragstart', function(e) {
      draggedEffect = effect;
      div.classList.add('dragging');
    });
    
    div.addEventListener('dragend', function(e) {
      div.classList.remove('dragging');
    });
    
    list.appendChild(div);
  });
}

function updateCostCalculation() {
  let totalCost = 0;
  let totalEffects = 0;
  
  effects.forEach(effect => {
    totalCost += (effect.price || 0) * (effect.quantity || 1);
    totalEffects += effect.quantity || 1;
  });
  
  document.getElementById('totalCost').textContent = `Gesamtkosten: ${totalCost.toFixed(2)} ‚Ç¨`;
  document.getElementById('effectCount').textContent = `Anzahl Effekte: ${totalEffects}`;
  
  updateEffectOverview();
}

function updateEffectOverview() {
  const overviewDiv = document.getElementById('overviewTable');
  
  if (effects.length === 0) {
    overviewDiv.innerHTML = '<p style="color: #666; font-style: italic;">Keine Effekte in der Show</p>';
    return;
  }
  
  // Sort effects by time
  const sortedEffects = [...effects].sort((a, b) => a.time - b.time);
  
  let html = `
    <table class="overview-table">
      <thead>
        <tr>
          <th>Zeit</th>
          <th>Effekt</th>
          <th>Typ</th>
          <th>Dauer</th>
          <th>Kanal</th>
          <th>Taste</th>
          <th>Empf√§nger</th>
          <th>Preis</th>
          <th>Anzahl</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  sortedEffects.forEach(effect => {
    html += `
      <tr>
        <td class="time-cell">${effect.timeStr}</td>
        <td><strong>${effect.name}</strong></td>
        <td>${effect.effectType}</td>
        <td>${effect.plannedDuration || '-'}</td>
        <td class="channel-cell">${effect.channel || '-'}</td>
        <td class="button-cell">${effect.buttonKey || '-'}</td>
        <td>${effect.receiver || '-'}</td>
        <td>${effect.price > 0 ? effect.price.toFixed(2) + '‚Ç¨' : '-'}</td>
        <td>${effect.quantity || 1}</td>
      </tr>
    `;
  });
  
  html += '</tbody></table>';
  overviewDiv.innerHTML = html;
}

function editEffect(id) {
  const effect = effects.find(e => e.id === id);
  if (!effect) return;
  
  // Erstelle Bearbeitungs-Modal
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 1000; display: flex;
    align-items: center; justify-content: center;
  `;
  
  modal.innerHTML = `
    <div style="background: #222; padding: 20px; border-radius: 10px; width: 400px; max-width: 90%;">
      <h3 style="margin-top: 0; color: #fff;">Effekt bearbeiten: ${effect.name}</h3>
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Showzeit (m:s):</label>
      <input id="editTime" value="${effect.timeStr}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Kanal:</label>
      <input id="editChannel" value="${effect.channel || ''}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Empf√§nger:</label>
      <input id="editReceiver" value="${effect.receiver || ''}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Taste:</label>
      <input id="editButtonKey" value="${effect.buttonKey || ''}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Anzahl:</label>
      <input id="editQuantity" type="number" value="${effect.quantity || 1}" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px;">
      
      <label style="color: #ccc; display: block; margin: 10px 0 5px;">Zusatzinfos:</label>
      <textarea id="editAdditionalInfo" style="width: 100%; padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 5px; height: 60px;">${effect.additionalInfo || ''}</textarea>
      
      <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
        <button onclick="this.parentElement.parentElement.parentElement.remove()" style="padding: 10px 15px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">Abbrechen</button>
        <button onclick="saveEffectEdit(${effect.id})" style="padding: 10px 15px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">Speichern</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
}

function saveEffectEdit(id) {
  const effect = effects.find(e => e.id === id);
  if (!effect) return;
  
  const newTime = document.getElementById('editTime').value;
  const newChannel = document.getElementById('editChannel').value;
  const newReceiver = document.getElementById('editReceiver').value;
  const newButtonKey = document.getElementById('editButtonKey').value;
  const newQuantity = parseInt(document.getElementById('editQuantity').value) || 1;
  const newAdditionalInfo = document.getElementById('editAdditionalInfo').value;
  
  // Aktualisiere Effekt
  effect.timeStr = newTime;
  effect.time = parseTime(newTime);
  effect.channel = newChannel;
  effect.receiver = newReceiver;
  effect.buttonKey = newButtonKey;
  effect.quantity = newQuantity;
  effect.additionalInfo = newAdditionalInfo;
  
  // Schlie√üe Modal
  document.querySelector('[style*="position: fixed"]').remove();
  
  // Aktualisiere Anzeige
  updateEffectList();
  updateCostCalculation();
  drawCanvas();
  
  alert(`Effekt "${effect.name}" wurde aktualisiert!`);
}

function deleteEffect(id) {
  if (confirm('Effekt wirklich l√∂schen?')) {
    effects = effects.filter(e => e.id !== id);
    updateEffectList();
    updateCostCalculation();
    drawCanvas();
  }
}

function drawCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw grid
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  for (let x = 0; x <= canvas.width; x += 50) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y <= canvas.height; y += 50) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
  
  // Draw effects
  effects.forEach(effect => {
    // Nur platzierte Effekte zeichnen
    if (effect.x !== null && effect.y !== null) {
      const colors = {
        rocket: '#ff4444',
        fountain: '#44ff44',
        battery: '#4444ff'
      };
      
      // Draw effect circle
      ctx.fillStyle = colors[effect.effectType] || '#ffffff';
      ctx.beginPath();
      ctx.arc(effect.x, effect.y, 8, 0, 2 * Math.PI);
      ctx.fill();
      
      // Draw image icon if available
      if (effect.image) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '16px Arial';
        ctx.fillText('üì∏', effect.x - 8, effect.y - 12);
      }
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '12px Arial';
      ctx.fillText(effect.name, effect.x + 12, effect.y + 4);
      ctx.fillText(effect.timeStr, effect.x + 12, effect.y + 16);
      
      // Show channel and button if available
      if (effect.channel && effect.buttonKey) {
        ctx.fillStyle = '#00ffff';
        ctx.fillText(`K${effect.channel}-T${effect.buttonKey}`, effect.x + 12, effect.y + 28);
      }
      
      // Show price if available
      if (effect.price > 0) {
        ctx.fillStyle = '#90ee90';
        ctx.fillText(`${effect.price}‚Ç¨`, effect.x + 12, effect.y + 40);
      }
    }
  });
  
  // Zeige Hinweis f√ºr nicht platzierte Effekte
  const unplacedEffects = effects.filter(effect => effect.x === null || effect.y === null);
  if (unplacedEffects.length > 0) {
    ctx.fillStyle = '#ffff00';
    ctx.font = 'bold 16px Arial';
    ctx.fillText(`${unplacedEffects.length} Effekt(e) noch nicht platziert`, 20, 30);
    ctx.font = '14px Arial';
    ctx.fillText('Klicke auf das Abbrennfeld um sie zu platzieren', 20, 50);
    
    // Zeige n√§chsten zu platzierenden Effekt
    if (unplacedEffects.length > 0) {
      ctx.fillStyle = '#ff8800';
      ctx.fillText(`N√§chster: "${unplacedEffects[0].name}"`, 20, 70);
    }
  }
}

function createExplosion(x, y, color) {
  const explosion = document.createElement('div');
  explosion.className = 'explosion';
  explosion.style.left = (x - 25) + 'px';
  explosion.style.top = (y - 25) + 'px';
  explosion.style.width = '50px';
  explosion.style.height = '50px';
  explosion.style.background = `radial-gradient(circle, ${color} 0%, transparent 70%)`;
  
  document.getElementById('canvasContainer').appendChild(explosion);
  
  setTimeout(() => {
    explosion.remove();
  }, 1000);
}

function loadSavedEffects() {
  const saved = localStorage.getItem('savedEffects');
  if (saved) {
    savedEffects = JSON.parse(saved);
    updateSavedEffectsList();
  }
}

function updateSavedEffectsList() {
  const select = document.getElementById('effectSavedList');
  select.innerHTML = '<option value="">Vorherige Effekte (' + savedEffects.length + ')</option>';
  
  savedEffects.forEach((effect, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = effect.name;
    select.appendChild(option);
  });
}

function selectSavedEffect() {
  const select = document.getElementById('effectSavedList');
  const index = select.value;
  
  if (index !== '') {
    const effect = savedEffects[index];
    document.getElementById('name').value = effect.name;
    document.getElementById('effectType').value = effect.effectType;
    document.getElementById('plannedDuration').value = effect.plannedDuration;
    document.getElementById('price').value = effect.price || '';
    document.getElementById('barcode').value = effect.barcode || '';
    document.getElementById('channel').value = effect.channel;
    document.getElementById('receiver').value = effect.receiver;
    document.getElementById('buttonKey').value = effect.buttonKey;
    document.getElementById('quantity').value = effect.quantity;
    document.getElementById('additionalInfo').value = effect.additionalInfo;
  }
}

function saveShow() {
  const showName = document.getElementById('showName').value || 'Unbenannte Show';
  const showData = {
    name: showName,
    effects: effects,
    timestamp: new Date().toISOString()
  };
  
  let savedShows = JSON.parse(localStorage.getItem('savedShows') || '[]');
  savedShows.push(showData);
  localStorage.setItem('savedShows', JSON.stringify(savedShows));
  
  alert('Show gespeichert!');
  loadSavedShows();
}

function loadSavedShows() {
  const select = document.getElementById('savedShows');
  select.innerHTML = '<option value="">Gespeicherte Shows</option>';
  
  const savedShows = JSON.parse(localStorage.getItem('savedShows') || '[]');
  savedShows.forEach((show, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = `${show.name} (${new Date(show.timestamp).toLocaleDateString()})`;
    select.appendChild(option);
  });
}

function selectShow() {
  const select = document.getElementById('savedShows');
  const index = select.value;
  
  if (index !== '') {
    const savedShows = JSON.parse(localStorage.getItem('savedShows') || '[]');
    const show = savedShows[index];
    
    document.getElementById('showName').value = show.name;
    effects = show.effects || [];
    updateEffectList();
    updateCostCalculation();
    drawCanvas();
  }
}

function exportShow() {
  const showName = document.getElementById('showName').value || 'Unbenannte Show';
  const showData = {
    name: showName,
    effects: effects,
    exportDate: new Date().toISOString()
  };
  
  const dataStr = JSON.stringify(showData, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `${showName}.json`;
  link.click();
  
  URL.revokeObjectURL(url);
}

function importShow() {
  const fileInput = document.getElementById('importFile');
  const file = fileInput.files[0];
  
  if (!file) {
    alert('Bitte eine Datei ausw√§hlen!');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const showData = JSON.parse(e.target.result);
      document.getElementById('showName').value = showData.name || 'Importierte Show';
      effects = showData.effects || [];
      updateEffectList();
      updateCostCalculation();
      drawCanvas();
      alert('Show erfolgreich importiert!');
    } catch (error) {
      alert('Fehler beim Importieren der Datei!');
    }
  };
  reader.readAsText(file);
}

function loadMusic() {
  const fileInput = document.getElementById('musicFile');
  const file = fileInput.files[0];
  
  if (file) {
    const url = URL.createObjectURL(file);
    const musicPlayer = document.getElementById('musicPlayer');
    musicPlayer.src = url;
    alert('Musik geladen!');
  }
}

function printPlan() {
  const printArea = document.getElementById('printArea');
  const showName = document.getElementById('showName').value || 'Unbenannte Show';
  
  let totalCost = 0;
  effects.forEach(effect => {
    totalCost += (effect.price || 0) * (effect.quantity || 1);
  });
  
  // Erstelle Canvas-Abbild f√ºr Druck
  const canvasImage = canvas.toDataURL();
  
  let html = `
    <style>
      @media print {
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #000; padding: 8px; text-align: left; font-size: 12px; }
        th { background-color: #f0f0f0; font-weight: bold; }
        .canvas-container { page-break-before: always; text-align: center; }
        .canvas-image { max-width: 100%; height: auto; border: 2px solid #000; }
        h1 { font-size: 24px; text-align: center; margin-bottom: 10px; }
        h2 { font-size: 18px; margin: 20px 0 10px 0; }
        .summary { background-color: #f9f9f9; padding: 15px; margin: 20px 0; border: 2px solid #000; }
      }
    </style>
    
    <h1>üéÜ ${showName}</h1>
    
    <div class="summary">
      <h2>üìä Show-√úbersicht</h2>
      <p><strong>Anzahl Effekte:</strong> ${effects.length}</p>
      <p><strong>Gesamtkosten:</strong> ${totalCost.toFixed(2)} ‚Ç¨</p>
      <p><strong>Show-Dauer:</strong> ${effects.length > 0 ? formatTime(Math.max(...effects.map(e => e.time))) : '0:00'}</p>
      <p><strong>Erstellt am:</strong> ${new Date().toLocaleDateString('de-DE')} um ${new Date().toLocaleTimeString('de-DE')}</p>
    </div>
    
    <h2>üéØ Effektliste (Zeitlich sortiert)</h2>
    <table>
      <tr>
        <th>Zeit</th>
        <th>Effekt</th>
        <th>Kanal</th>
        <th>Taste</th>
        <th>Empf√§nger</th>
        <th>Position</th>
        <th>Anzahl</th>
        <th>Preis</th>
      </tr>
  `;
  
  effects.sort((a, b) => a.time - b.time);
  effects.forEach(effect => {
    const position = (effect.x !== null && effect.y !== null) 
      ? `X:${Math.round(effect.x)}, Y:${Math.round(effect.y)}` 
      : 'Nicht platziert';
    
    html += `
      <tr>
        <td><strong>${effect.timeStr}</strong></td>
        <td>${effect.name}</td>
        <td>${effect.channel || '-'}</td>
        <td>${effect.buttonKey || '-'}</td>
        <td>${effect.receiver || '-'}</td>
        <td>${position}</td>
        <td>${effect.quantity}</td>
        <td>${effect.price ? effect.price.toFixed(2) + '‚Ç¨' : '-'}</td>
      </tr>
    `;
  });
  
  html += `
    </table>
    
    <div class="canvas-container">
      <h2>üó∫Ô∏è Abbrennplatz-Layout</h2>
      <img src="${canvasImage}" class="canvas-image" alt="Abbrennplatz Layout">
      <p><em>Legende: üî¥ Raketen | üü¢ Font√§nen | üîµ Batterien</em></p>
    </div>
  `;
  
  printArea.innerHTML = html;
  printArea.style.display = 'block';
  
  window.print();
  
  setTimeout(() => {
    printArea.style.display = 'none';
  }, 1000);
}

function generateQRCode() {
  // Create a unique session ID for this show
  const sessionId = 'show_' + Date.now();
  const showData = {
    name: document.getElementById('showName').value || 'Unbenannte Show',
    effects: effects,
    database: effectDatabase,
    sessionId: sessionId
  };
  
  // Store in localStorage with session ID
  localStorage.setItem(sessionId, JSON.stringify(showData));
  
  const dataStr = JSON.stringify(showData);
  const encodedData = btoa(dataStr);
  const remoteUrl = `${window.location.origin}${window.location.pathname}?session=${sessionId}&remote=${encodedData}`;
  
  // Simple QR code representation
  const qrDiv = document.getElementById('qrCode');
  qrDiv.innerHTML = `
    <div style="width: 200px; height: 200px; background: white; margin: 0 auto; display: flex; align-items: center; justify-content: center; border: 2px solid #000;">
      <div style="color: black; text-align: center; font-size: 10px;">
        üéÜ FirePlanner<br>
        Session: ${sessionId.substring(5, 15)}<br>
        <div style="font-size: 8px; margin-top: 10px;">
          Scanne mit Smartphone<br>
          f√ºr Remote-Zugriff
        </div>
      </div>
    </div>
  `;
  
  document.getElementById('remoteUrl').innerHTML = `
    <div style="margin-top: 15px;">
      <strong>Session-ID:</strong> ${sessionId}<br>
      <small>URL: <a href="${remoteUrl}" target="_blank" style="color: #4caf50;">Auf anderem Ger√§t √∂ffnen</a></small><br>
      <small style="color: #999;">Teile diese URL oder Session-ID mit anderen Ger√§ten</small>
    </div>
  `;
  
  document.getElementById('qrModal').style.display = 'block';
}

function loadFromSession() {
  const sessionId = prompt('Session-ID eingeben:');
  if (sessionId) {
    const sessionData = localStorage.getItem(sessionId);
    if (sessionData) {
      try {
        const showData = JSON.parse(sessionData);
        document.getElementById('showName').value = showData.name;
        effects = showData.effects || [];
        if (showData.database) {
          effectDatabase = showData.database;
          localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
          updateDatabaseList();
        }
        updateEffectList();
        updateCostCalculation();
        drawCanvas();
        alert('Show von Session geladen!');
      } catch (error) {
        alert('Fehler beim Laden der Session!');
      }
    } else {
      alert('Session nicht gefunden!');
    }
  }
}

function closeQRModal() {
  document.getElementById('qrModal').style.display = 'none';
}

function startAutoBackup() {
  autoBackupInterval = setInterval(() => {
    const backupData = {
      shows: JSON.parse(localStorage.getItem('savedShows') || '[]'),
      effects: savedEffects,
      database: effectDatabase,
      timestamp: new Date().toISOString()
    };
    
    localStorage.setItem('autoBackup', JSON.stringify(backupData));
    
    // Show backup notification
    const status = document.getElementById('backupStatus');
    status.style.display = 'block';
    setTimeout(() => {
      status.style.display = 'none';
    }, 2000);
  }, 300000); // Every 5 minutes
}

function autoBackup() {
  const backupData = {
    shows: JSON.parse(localStorage.getItem('savedShows') || '[]'),
    effects: savedEffects,
    database: effectDatabase,
    timestamp: new Date().toISOString()
  };
  
  const dataStr = JSON.stringify(backupData, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `FirePlanner_Backup_${new Date().toISOString().split('T')[0]}.json`;
  link.click();
  
  URL.revokeObjectURL(url);
  alert('Backup erstellt und heruntergeladen!');
}


// ===== Timeline Anzeige =====
function updateTimeline(elapsed) {
  const timeline = document.getElementById('timelineDisplay');
  if (!timeline) return;
  const totalTime = Math.max(...effects.map(e => e.time)) || 1;
  const progressPercent = Math.min(100, Math.max(0, (elapsed / totalTime) * 100));

  timeline.innerHTML = `
    <div style="width: 100%; background: #333; border-radius: 6px; height: 28px; position: relative; overflow: hidden; border: 1px solid #444;">
      <div style="width: ${progressPercent}%; height: 100%; background: linear-gradient(90deg,#4caf50,#81c784); transition: width 0.3s;"></div>
      <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); color: #fff; font-size: 12px; line-height: 28px;">
        ${formatTime(elapsed)} / ${formatTime(totalTime)}
      </div>
    </div>
    <div style="margin-top:6px; font-size:12px; color:#ccc; text-align:left;">
      ${effects
        .slice().sort((a,b)=>a.time-b.time)
        .map(e => {
          const marker = (e.time <= elapsed) ? '‚óè' : '‚óã';
          return `<span style="margin-right:8px;">${marker} ${e.timeStr || formatTime(e.time)} ${e.name}</span>`;
        }).join('')}
    </div>
  `;
}
// ===== Ende Timeline =====

function startShow() {
  if (effects.length === 0) {
    alert('Keine Effekte in der Show!');
    return;
  }
  
  document.getElementById('planScreen').style.display = 'none';
  document.getElementById('showScreen').style.display = 'block';
  
  showStartTime = Date.now();
  isPaused = false;
  pausedTime = 0;
  
  // Start music if loaded
  const musicPlayer = document.getElementById('musicPlayer');
  if (musicPlayer.src) {
    musicPlayer.currentTime = 0;
    musicPlayer.play().catch(() => {});
  }
  
  runShow();
}

function runShow() {
  showTimer = setInterval(() => {
    if (isPaused) return;
    
    const elapsed = Math.floor((Date.now() - showStartTime - pausedTime) / 1000);
    document.getElementById('timerDisplay').textContent = formatTime(elapsed);
    
    // Check for upcoming effects
    const upcomingEffects = effects.filter(e => 
      e.time > elapsed && e.time <= elapsed + 10
    );
    
    if (upcomingEffects.length > 0) {
      const nextEffect = upcomingEffects[0];
      const timeToEffect = nextEffect.time - elapsed;
      
      document.getElementById('warning').innerHTML = `‚ö†Ô∏è <strong>${nextEffect.name}</strong> in ${timeToEffect}s<br>üî∏ Kanal: <span style="color:#0ff;">${nextEffect.channel || '-'}</span> | Taste: <span style="color:#ff0;">${nextEffect.buttonKey || '-'}</span>`;
      
      if (timeToEffect <= 3) {
        flashWarning();
        document.getElementById('warningBeep').play().catch(() => {});
      }
    } else {
      document.getElementById('warning').innerHTML = '';
    }
    
    // Check for current effects
    const currentEffects = effects.filter(e => e.time === elapsed);
    if (currentEffects.length > 0) {
      try{ document.getElementById('fireBeep').currentTime = 0; document.getElementById('fireBeep').play().catch(()=>{}); }catch(e){}

      const effect = currentEffects[0];
      document.getElementById('currentEffect').innerHTML = 
        `<div style="font-size: 1.8em; color: #ff0; text-align: center; background: #333; padding: 15px; border-radius: 10px; border: 3px solid #ff0;">
          üéÜ <strong>FEUER FREI!</strong><br>
          <div style="font-size: 1.2em; margin: 10px 0;">${effect.name}</div>
          <div style="font-size: 2em; color: #0ff; font-weight: bold;">
            KANAL ${effect.channel} - TASTE ${effect.buttonKey}
          </div>
          <div style="font-size: 0.8em; color: #ccc; margin-top: 5px;">
            ${effect.receiver ? 'Empf√§nger: ' + effect.receiver : ''}
          </div>
        </div>`;
      document.getElementById('fireBeep').play().catch(() => {});
      
      // Create explosion animation
      const colors = {
        rocket: '#ff4444',
        fountain: '#44ff44',
        battery: '#4444ff'
      };
      createExplosion(effect.x, effect.y, colors[effect.effectType] || '#ffffff');
      
      setTimeout(() => {
        document.getElementById('currentEffect').innerHTML = '';
      }, 5000);
    }
    
    // Update timeline
    updateTimeline(elapsed);
    
  }, 1000);
}

function flashWarning() {
  const flash = document.getElementById('warningFlash');
  flash.style.opacity = '0.3';
  setTimeout(() => {
    flash.style.opacity = '0';
  }, 200);
}

function updateTimeline(currentTime) {
  const timeline = document.getElementById('timelineDisplay');
  const upcomingEffects = effects
    .filter(e => e.time > currentTime)
    .slice(0, 5)
    .map(e => `${formatTime(e.time)}: ${e.name}`)
    .join(' | ');
  
  timeline.innerHTML = `<strong>N√§chste Effekte:</strong><br>${upcomingEffects || 'Keine weiteren Effekte'}`;
}

function pauseShow() {
  if (!isPaused) {
    isPaused = true;
    pausedTime += Date.now() - showStartTime;
    
    const musicPlayer = document.getElementById('musicPlayer');
    musicPlayer.pause();
  }
}

function resumeShow() {
  if (isPaused) {
    isPaused = false;
    showStartTime = Date.now();
    
    const musicPlayer = document.getElementById('musicPlayer');
    musicPlayer.play().catch(() => {});
  }
}

function stopShow() {
  clearInterval(showTimer);
  isPaused = false;
  
  const musicPlayer = document.getElementById('musicPlayer');
  musicPlayer.pause();
  musicPlayer.currentTime = 0;
  
  backToPlan();
}

function backToPlan() {
  document.getElementById('showScreen').style.display = 'none';
  document.getElementById('planScreen').style.display = 'block';
  
  document.getElementById('timerDisplay').textContent = '00:00';
  document.getElementById('warning').innerHTML = '';
  document.getElementById('currentEffect').innerHTML = '';
  document.getElementById('timelineDisplay').textContent = '';
}

// Function testing and validation
function testAllFunctions() {
  console.log('üîß Testing FirePlanner functions...');
  
  // Test image functions
  console.log('‚úÖ Image functions loaded');
  
  // Test database functions
  console.log('‚úÖ Database functions loaded');
  
  // Test effect creation
  console.log('‚úÖ Effect creation functions loaded');
  
  // Test canvas drawing
  console.log('‚úÖ Canvas functions loaded');
  
  // Test show timer
  console.log('‚úÖ Show timer functions loaded');
  
  console.log('üéÜ All FirePlanner functions ready!');
}

// Test database functionality
function testDatabase() {
  console.log('üß™ Teste Datenbank-Funktionalit√§t...');
  
  // Test 1: Pr√ºfe ob Datenbank existiert
  console.log('Test 1 - Datenbank-Variable:', effectDatabase);
  console.log('Test 1a - Datenbank-L√§nge:', effectDatabase.length);
  
  // Test 2: Pr√ºfe LocalStorage
  const stored = localStorage.getItem('effectDatabase');
  console.log('Test 2 - LocalStorage:', stored ? 'Vorhanden' : 'Leer');
  if (stored) {
    try {
      const parsed = JSON.parse(stored);
      console.log('Test 2a - LocalStorage-L√§nge:', parsed.length);
      console.log('Test 2b - Erste 3 Effekte:', parsed.slice(0, 3));
    } catch (error) {
      console.error('Test 2c - Fehler beim Parsen:', error);
    }
  }
  
  // Test 3: Pr√ºfe Dropdown-Element
  const dropdown = document.getElementById('effectDatabase');
  console.log('Test 3 - Dropdown-Element:', dropdown ? 'Gefunden' : 'Nicht gefunden');
  
  if (dropdown) {
    console.log('Test 3a - Dropdown-Optionen:', dropdown.options.length);
  }
  
  // Test 4: Konsistenz-Check
  if (stored) {
    try {
      const parsed = JSON.parse(stored);
      if (parsed.length === effectDatabase.length) {
        console.log('‚úÖ Test 4 - Variable und LocalStorage sind konsistent');
      } else {
        console.error('‚ùå Test 4 - INKONSISTENZ gefunden!');
        console.error('Variable:', effectDatabase.length, 'LocalStorage:', parsed.length);
      }
    } catch (error) {
      console.error('‚ùå Test 4 - Fehler bei Konsistenz-Check:', error);
    }
  }
  
  console.log('üß™ Datenbank-Test abgeschlossen!');
}

// Neue Funktion: Speicher-Persistenz testen
function testPersistence() {
  console.log('üî¨ Teste Speicher-Persistenz...');
  
  const testEffect = {
    name: 'TEST_EFFEKT_' + Date.now(),
    effectType: 'rocket',
    duration: '0:05',
    price: 99.99,
    barcode: 'TEST123',
    addedDate: new Date().toISOString()
  };
  
  console.log('üìù F√ºge Test-Effekt hinzu:', testEffect.name);
  
  // Speichere aktuellen Zustand
  const originalLength = effectDatabase.length;
  
  // F√ºge Test-Effekt hinzu
  effectDatabase.push(testEffect);
  localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
  
  // Sofort pr√ºfen
  const immediate = localStorage.getItem('effectDatabase');
  const immediateData = JSON.parse(immediate);
  
  if (immediateData.length === originalLength + 1) {
    console.log('‚úÖ Sofortige Speicherung erfolgreich');
    
    // Simuliere Neustart durch Neuladen der Datenbank
    loadEffectDatabase();
    
    // Pr√ºfe ob Test-Effekt noch da ist
    const foundEffect = effectDatabase.find(e => e.name === testEffect.name);
    if (foundEffect) {
      console.log('‚úÖ Test-Effekt nach Neuladung gefunden:', foundEffect.name);
      console.log('‚úÖ PERSISTENZ-TEST ERFOLGREICH!');
      
      // Entferne Test-Effekt wieder
      effectDatabase = effectDatabase.filter(e => e.name !== testEffect.name);
      localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
      updateDatabaseList();
      console.log('üßπ Test-Effekt entfernt');
    } else {
      console.error('‚ùå Test-Effekt nach Neuladung NICHT gefunden!');
      console.error('‚ùå PERSISTENZ-TEST FEHLGESCHLAGEN!');
    }
  } else {
    console.error('‚ùå Sofortige Speicherung fehlgeschlagen');
  }
  
  console.log('üî¨ Persistenz-Test abgeschlossen!');
}

// Search functions for large databases
function showSearch() {
  const searchInput = document.getElementById('effectSearch');
  const dropdown = document.getElementById('effectDatabase');
  
  if (searchInput && dropdown) {
    searchInput.style.display = 'block';
    dropdown.style.display = 'none';
    searchInput.focus();
    searchInput.value = '';
  }
}

function hideSearch() {
  setTimeout(() => {
    const searchInput = document.getElementById('effectSearch');
    const dropdown = document.getElementById('effectDatabase');
    
    if (searchInput && dropdown) {
      searchInput.style.display = 'none';
      dropdown.style.display = 'block';
    }
  }, 200);
}

function searchEffects() {
  const searchTerm = document.getElementById('effectSearch').value.toLowerCase();
  const dropdown = document.getElementById('effectDatabase');
  
  if (!searchTerm || searchTerm.length < 2) {
    return;
  }
  
  // Suche in der Datenbank
  const matches = effectDatabase.filter((effect, index) => {
    const searchText = `${effect.name} ${effect.barcode || ''} ${effect.effectType || ''}`.toLowerCase();
    return searchText.includes(searchTerm);
  }).slice(0, 20); // Maximal 20 Ergebnisse
  
  if (matches.length > 0) {
    // Zeige Suchergebnisse
    dropdown.innerHTML = '';
    
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = `üîç ${matches.length} Ergebnisse f√ºr "${searchTerm}"`;
    dropdown.appendChild(defaultOption);
    
    matches.forEach(effect => {
      const index = effectDatabase.indexOf(effect);
      const option = document.createElement('option');
      option.value = index.toString();
      
      const price = (effect.price && effect.price > 0) ? ` ${effect.price}‚Ç¨` : '';
      const shortName = effect.name.length > 25 ? effect.name.substring(0, 25) + '...' : effect.name;
      
      option.textContent = `${shortName}${price}`;
      select.appendChild(option);
    });
    
    // Zeige Dropdown mit Ergebnissen
    document.getElementById('effectSearch').style.display = 'none';
    dropdown.style.display = 'block';
  }
}

// Check for remote control URL parameter
window.addEventListener('load', function() {
  // Test all functions on load
  testAllFunctions();
  
  // Test database after a short delay
  setTimeout(() => {
    console.log('üîß Starte Datenbank-Test nach 1 Sekunde...');
    testDatabase();
  }, 1000);
  
  const urlParams = new URLSearchParams(window.location.search);
  const remoteData = urlParams.get('remote');
  const sessionId = urlParams.get('session');
  
  if (remoteData) {
    try {
      const showData = JSON.parse(atob(remoteData));
      document.getElementById('showName').value = showData.name;
      effects = showData.effects || [];
      
      if (showData.database) {
        effectDatabase = showData.database;
        localStorage.setItem('effectDatabase', JSON.stringify(effectDatabase));
        updateDatabaseList();
      }
      
      updateEffectList();
      updateCostCalculation();
      drawCanvas();
      alert(`Show "${showData.name}" von anderem Ger√§t geladen!`);
      
      // Store session for future access
      if (sessionId) {
        localStorage.setItem(sessionId, JSON.stringify(showData));
      }
    } catch (error) {
      console.error('Fehler beim Laden der Remote-Daten');
    }
  }
});
</script>

<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'987d2896e2bbfcd5',t:'MTc1OTMzNDI3NS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();
/* ==========================================================
   üåê GitHub Cloud Integration
   ========================================================== */

// Helper: try different auth schemes (token then Bearer) to handle PAT variants
async function authFetch(url, options) {
  const token = githubConfig.token;
  if (!token) throw new Error('Kein GitHub Token gesetzt');

  const tryWith = async (scheme) => {
    const headers = Object.assign({}, options && options.headers ? options.headers : {});
    headers['Authorization'] = scheme + ' ' + token;
    const opts = Object.assign({}, options || {}, { headers });
    return fetch(url, opts);
  };

  let res = await tryWith('token');
  // If unauthorized, try Bearer scheme (some tokens need this)
  if (res && res.status === 401) {
    res = await tryWith('Bearer');
  }
  return res;
}

  if (!githubConfig.user) {
    githubConfig.user = prompt("üë§ Dein GitHub Benutzername:");
  }
  if (!githubConfig.repo) {
    githubConfig.repo = prompt("üì¶ Repo-Name f√ºr Backup:");
  }
  if (!githubConfig.token) {
    githubConfig.token = prompt("üîë Personal Access Token (mit repo-Rechten):");
  }
}

async function githubBackup() {
  if (!ensureGithubConfigInteractive()) return;

  const backupData = {
    shows: JSON.parse(localStorage.getItem('savedShows') || '[]'),
    effects: savedEffects,
    database: effectDatabase,
    timestamp: new Date().toISOString()
  };

  const content = btoa(unescape(encodeURIComponent(JSON.stringify(backupData, null, 2))));

  const url = `https://api.github.com/repos/${githubConfig.user}/${githubConfig.repo}/contents/${githubConfig.file}`;

  let sha = null;
  try {
    const checkRes = await authFetch(url, { method: 'GET' });
    if (checkRes.ok) {
      const checkData = await checkRes.json();
      sha = checkData.sha;
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Fehler beim Pr√ºfen:", err);
  }

  const res = await authFetch(url, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'üíæ FirePlanner Backup', content: content, sha: sha || undefined }) });

  if (res.ok) {
    alert("‚úÖ Backup erfolgreich auf GitHub gespeichert!");
  } else {
    let text;
    try {
      const error = await res.json();
      text = JSON.stringify(error, null, 2);
    } catch(e){
      text = await res.text();
    }
    alert("‚ùå Fehler beim Backup:\n" + text);
  }
}

async function githubRestore() {
  if (!ensureGithubConfigInteractive()) return;

  const url = `https://api.github.com/repos/${githubConfig.user}/${githubConfig.repo}/contents/${githubConfig.file}`;

  const res = await authFetch(url, { method: 'GET' });

  if (!res.ok) {
    let errtxt;
    try { errtxt = JSON.stringify(await res.json(), null, 2); } catch(e) { errtxt = await res.text(); }
    alert("‚ùå Konnte Backup nicht laden!\n" + errtxt);
    return;
  }

  const data = await res.json();
  const content = decodeURIComponent(escape(atob(data.content)));
  const backupData = JSON.parse(content);

  localStorage.setItem('savedShows', JSON.stringify(backupData.shows || []));
  localStorage.setItem('effectDatabase', JSON.stringify(backupData.database || []));
  savedEffects = backupData.effects || [];

  loadSavedShows();
  updateDatabaseList();
  updateSavedEffectsList();

  alert("‚úÖ Backup aus GitHub geladen!");
}

</script></body>
</html>
